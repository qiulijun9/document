https://juejin.im/post/5a1d4e546fb9a0450f21af23
https://juejin.im/post/5df5bcea6fb9a016091def69

# 缓存的分类

1. Memory Cache(内存中的缓存,最快的) 一些体积不大的 js,css 会被写入内存.
2. Service Worker Cache(独立于主线程之外的线程)会处理离线缓存,或消息推送等功能. 必须是以 https 协议为前提.
   离线缓存:window.navigator.serviceWorker.register('/test.js')
3. Http Cache
4. Push Cache(是缓存最后一道防线)

浏览器存在一个缓存数据库，来存储不经常变化的静态文件（图片，css,js），http 缓存分为强制缓存和协商缓存。
强制缓存高于协商缓存，当执行强制缓存时，如果缓存命中，则直接使用缓存数据库，不在进行协商缓存。

# 强制缓存

当缓存数据库有请求的数据时，客户端直接从缓存数据库中获取，没有时才会从服务端获取数据。
强制缓存服务器响应会用 header 中的两个字段来表明：Cache-Control,Expires

1. Expires:服务端返回的数据过期时间，当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。过期则重新发送请求，这个时间可能有误差（绝对时间）所以引入了 Cache-Control,Expires 只是为了做向后兼容
2. Cache-Control 有很多属性，不同的属性代表的意义也不同。
   private:客户端可以缓存
   public:客户端和代理服务器都可以缓存
   max-age=t：缓存内容在 t 秒后消失, 和 Expires 字段相比，会优先处理 max-age 的指令
   no-cache:需要使用协商缓存来缓存数据
   no-store:所有内容都不会缓存

# 协商缓存

客户端会从缓存数据库中拿到一个缓存数据的标识，拿个这个标识去服务端校验是否失效，如果未失效服务端返回 304，客户端从缓存数据库中获取，如果失效，服务端会返回更新后的数据。

1. Last-Modified： 最后修改时间。
   lf-Modified-Since :浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着最后修改时间，
   服务端会拿 lf-Modified-Since 和 Last-Modified 进行对比，如果一致返回 304，浏览器从缓存中获取信息。
   if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，如果没有被修改，则继续传送文件，如果被修改，则不传输。缺点是如果编译了文件,但是没有修改,还是会被当成新的资源来进行重新渲染的.
2. Etag:当前资源在服务器生成的唯一标识（hash）,只要文件内容不同,它对应的 Etag 也不同.

If-None-Match :再次请求时，报文头会包含此字段，后面跟着从缓存中获取的唯一标识，服务器会拿 If-None-Match 与 Etag 做对比，不同则响应整个资源内容，返回 200 ，相同，浏览器直接从缓存数据库作用获取数据，返回状态码 304

# 缓存的优点

1. 减少了冗余的数据传递，节省带宽流量
2. 减少服务器的负担，大大提高了网站性能
3. 加快了客户端加载网页的速度
