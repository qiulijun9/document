# TCP(传输控制协议)

是面向连接的协议,
在发送数据前必须和对方通过三次握手建立可靠的连接,保证数据的正确性和顺序

# UDP(用户数据报协议)

是面向无连接的协议,不安全
传输的数据包只有 8 个字节.是面向报文的,可能会丢包,不能保证传输数据的顺序

# 3 次握手 4 次挥手

3 次是最安全的次数，2 次不安全，4 次浪费资源

3 次握手：
客户端发送数据包到服务器 ------ 服务器收到请求后给与响应 ------ 客户端会再发送 请求连接成功
实际上是确认双方的发送和接收能力都正常。
第一次握手，确认客户端的发送能力
第二次握手，确认服务端的接收能力和发送能力
第三次握手，确认客户端的接收能力

2 次握手：
无法确认客户端的接收能力
当两次握手建立了连接，如果客户端断开了，网络中滞留的包如果到达了服务端，服务端还会建立连接给客户端发送数据，此时客户端已经断开了连接，就造成了连接资源的浪费

4 次挥手：
客户端要断开连接，向服务器发送 FIN=1 报文,提出要中断连接的请求
服务器端接收并给予客户端响应,响应信息为 ACK=1,因为这时可能还有数据包没有传完,不能立即中断.
服务端再检查数据包传送完之后，提出正式关闭的请求，将 FIN 置为 1
客户端确认关闭连接请求,双方断开连接

## 三次握手的时候可以携带数据吗

第三次握手的时候可以携带，前两次握手的时候不能携带数据。
如果在第一次握手的时候携带数据，如果有人攻击服务器，可能会携带大量的数据让服务端响应，这样就增大了服务器端被攻击的风险。
第三次握手的时候，客户端已经确认了服务端的接收和发送能力，相对比较安全，这时就可以携带数据了。

## 为什么要四次挥手

在服务端接收到客户端的 FIN ，不会立即返回 FIN，会等所有的数据包传完之后，才能发送，所以会先发一个 ACK，来代表接收到客户端的消息了，等数据包传送完之后，才发 FIN.这就造成了 4 次挥手

## tcp 连接能发几个 http 请求

http.1.0 不支持长连接，每次请求发送完毕，连接就会断开，所以只能发送一个 http 请求。
http1.1 支持长连接，只要 tcp 连接不断开，就一直能发请求,持续不断，没有上限
http2.0 支持多路复用，可以并发多个 http 请求，也支持长连接，连接不断，就能一直发送 http 请求

https 之所以能保障数据安全传输，是在 http 下面增加了一层 SSL/TLS 协议。

SSL：安全套接字，在发展到第三个版本的时候成为 TLS

现在主流的是 TLS/1.2，之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。

# 传统的 RSA 握手过程：

通过对称加密+非对称加密+数字证书一起实现

第一次握手：浏览器发送 client_random，和加密方法给服务器，
第二次握手：服务端发送 server_random,加密方法，数字证书给浏览器
第三个握手：浏览器验证数字证书通过后生成 pre_random,在把 server_random,client_random,pre_random,一起通过公钥加密生成一个随机数。发送给服务端，服务器通过私钥解密获得该随机数。之后的传输都使用这个随机数进行加密解密。

# TLS1.2 握手过程

第一次握手：浏览器发送 client_random,TLS 版本，加密套件列表给服务器，
第二次握手：服务器发送 server_random,确认 TLS 版本，使用加密套接列表，证书
第三次握手：浏览器通过 server_params 和 client_params 通过 ECDHE 算法计算出 Pre_random,用 client_random、server_random 和 pre_random，这三个数通过一个伪随机数函数来计算出最终的 secret。
服务端通过 ECDHE 算法计算出 pre_random，计算出 secret

# TLS 1.3 改进

1. 强化安全
   对称加密剩下 AES 和 CHACHA20 ，分组模式剩下 GCM,POLY1305，哈希摘要算法剩下，sha256,sha384,之前的 RSA 非对称加密算法不在了
2. 提升性能
   服务端不必等待对方验证证书之后才拿到 client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算 secret

# tcp 报文头部

源端口，目标端口：
如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。
那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。

序列号：指的是本报文段第一个字节的序列号。在 SYN 报文中交换彼此的初始序列号。保证数据包按正确的顺序组装

ISN: 三次握手中会通过 ISN 报文来交换彼此的 ISN

确认号：用来告知对方下一个期望接收的序列号

标记位:常见的标记位有 SYN,ACK,FIN,RST,PSH。
FIN 即 Finish，表示发送方准备断开连接。RST：即 Reset，用来强制断开连接。 PSH： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用.]

窗口大小:占用两个字节，也就是 16 位，
校验和:防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之,重传

可选项

## tcp 拥塞控制(慢启动,拥塞避免,快重传,快恢复)

拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。

### 慢启动（采用一种保守的方法来适应网络）

刚开始数据传输的时候，不能确定网络的安全性，不能发送的太急，可能会造成丢包的现象。
慢启动过程：

1. 3 次握手，建立连接
2. 初始化自己的拥塞窗口大小，比如是 10,一个单位的数据
3. 在开始传输，发送端接收到一个 ACK ，拥塞窗口加 1，如等第一轮 10 个报文传输完后，拥塞窗口变为 20(指数级的增加) ，以此类推，第二轮变 40 ，第三轮变 80

### 拥塞避免

拥塞避免是为了控制拥塞窗口增加过快。到阀值之后，原来每收到一个 ACK，cwnd 加 1，现在到达阈值了，cwnd 只能加这么一点: 1 / cwnd(变成线性增长)。

### 快重传

在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。
比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传。

### 快速恢复

发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。
在这个阶段，发送端如下改变：

1. 拥塞阈值降低为 cwnd 的一半
2. cwnd 的大小变为拥塞阈值
3. cwnd 线性增加
