# 常见的 web 攻击方式：

1. SQL 注入

2. XSS(跨站脚本攻击)：（指浏览器中执行恶意脚本）
   通过某种方式，将特定的 js 代码隐蔽的输入进去,从而在用户浏览网页时，对用户浏览器进行控制，或者获取用户隐私的一种攻击方式。

XSS 攻击可以分为 3 类：反射型(非持久型)，存储型(持久型)，文档型
反射型：
指恶意脚本作为网络请求的一部分。这种攻击方式需要诱导用户点击某个恶意链接，服务端返回一个可执行的脚本。

存储型：
存储型 xss 会把用户输入的数据存储在服务器端，当浏览器请求数据时，脚本从服务器端回传并执行。这种攻击具有很强的稳定性。（比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码）

文档型：
是指通过恶意脚本修改 DOM 结构，是纯粹发生在客户端的攻击。（用户点击按钮时，插入恶性的链接，本地恶意软件）

## 解决方法：（一个信念，两个利用）

一个信念：不要相信用户的输入，无论是在前端还是后端都要做转义和过滤
(1)输入检查：对用户的任意输入都要检查，转义，过滤。建立可信任的字符和白名单，对不在白名单之内的都进行过滤。对特殊字符 < > 进行过滤和编码。
输出检查：利用 sanitize-html 对输出内容进行过滤转义，或限制长度，后在输出到页面中

(2)利用 HttpOnly 防止劫取 Cookie ：浏览器禁止 js 的访问带有 httpOnly 属性的 Cookie,

(3)利用 csp:服务器决定浏览器加载哪些资源
a. 限制其他域下资源加载
b. 禁止向其他域提交数据
c. 提供上报机制

3. CSRF(跨站请求伪造)：借助 cookie 的信息，劫持操作者的权限来偷偷完成某个操作。
   诱导用户点击链接，跳转到黑客网站，黑客利用 cookie 信息来发起跨站伪造请求。

## 解决方法：

(1)利用 cookie 的 SameSite 属性

SameSite 可以设置三个值：
strict:禁止第三方请求携带 cookie
lax:比较宽松，在 form 提交和 a 链接中能携带 cookie，其他均不可。
none：默认，请求自动携带 cookie

(2) 验证来源站点
利用请求头的 origin 和 referer 字段。
origin 只有域名信息，Referer 记录了 http 请求的来源地址
referer Check:http 中有个字段 Referer,记录了 http 请求的来源地址，通过 referer check 可以检查请求是否来自合法的源
(3) 添加 token 验证
（HTTP 请求中加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求）
（4）验证码
