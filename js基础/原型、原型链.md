_proto_ 是每个实例都有的属性，prototype 是构造函数的属性，这两个并不一样，但 _proto_ 和 对象.prototype 指向同一个对象 实例._prpto_ === 构造函数.prototype

prototype 和*proto*区别：
prototype 是函数才有的属性，_ptoto_ 是每个对象都有的属性

# 原型链

每个对象都拥有一个原型对象，通过 _proto_ 指向上一个原型，并从中继承方法和属性，同时原型对象也可能有原型，在指向上层，...最终指向 null

# 原型链应用

公有的属性写在原型上
instanceof :用来判断对象是否为指定的实例，如果函数的原型出现在对象的原型链上的话，返回 true ,则返回 false
for in :使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问，可以用 obj. hasOwnProperty 来过滤

# 继承

判断原型和实例的继承方法：

1. instanceof: a.instanceof Object
   a.instanceof B 判断 B.prototype 是否出现在 a._prpto_ 上
2. isPrototypeOf: Object.prototypeOf(a)
   判断指定对象是否存在于另一个对象的原型链中

## 构造继承：

在子类的构造函数内部调用父类的构造函数
缺点：只能继承父类的实例属性和方法，不能继承父类原型的属性和方法

```
function child(){
  Parent.call(this,...argument)
}
```

## 原型链继承

将子类的原型对象指向父类的实例 child.prototype = new Parent()

优点：继承了父类的方法和属性，以及父类原型对象
缺点：
在更改父类原型对象上的值（引用类型的数据时）创建的子类实例对象也发生改变
子类无法向父类的构造函数传参
无法实现多继承

## 组合继承：

使用原型链实现对父类原型属性和方法的继承，借用构造函数实现对父类属性和方法的继承
缺点：调用了两次构造函数 （一次在创建子类型原型的时候，另一次在子类的构造函数内部）

```
child.prototype = new Parent()
function child(){
  Parent.call(this,...argument)
}
```

## 寄生式继承

是创建一个封装了继承过程的函数，在函数内部添加方法和属性，再返回该对象
缺点：使用寄生式继承给对象添加函数，不能做到函数复用

## 组合寄生式继承

不必为了指定子类型的原型而调用父类的构造函数

child.prototype = Object.create(Parent.prototype)
function child(){
Parent.call(this,...argument)
}

## class 继承

创造父类的实例对象 this,使用子类的构造函数去修改 this
依靠 extends 和 super 同组合寄生式继承
class 通过 extends 继承父类的属性和方法，若子类中没有实现 constructor 方法，会默认调用 constructor

```
class Parent{
  constructor(name){
    this.name = name
  }
  getName(){
    console.log(this.name)
  }
}

class Child extends Parent{
  constructor(name){
    super(name)
  }
}
```

const obj = {};
for (let i=0; i<len; i++) {
!obj[arr[i]] && obj[arr[i]] = true && newArr.push(arr[i]);
}
