_proto_ 是每个实例都有的属性，prototype 是构造函数的属性，这两个并不一样，但 _proto_ 和 对象.prototype 指向同一个对象 实例._prpto_ === 构造函数.prototype

prototype 和*proto*区别：
prototype 是函数才有的属性，_ptoto_ 是每个对象都有的属性

# 原型链

每个对象都拥有一个原型对象，通过 _proto_ 指向上一个原型，并从中继承方法和属性，同时原型对象也可能有原型，在指向上层，...最终指向 null

# 原型链应用

公有的属性写在原型上
instanceof :用来判断对象是否为指定的实例，如果函数的原型出现在对象的原型链上的话，返回 true ,则返回 false
for in :使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问，可以用 obj. hasOwnProperty 来过滤

for in 可以遍历对象，for of 不可以

# 继承

判断原型和实例的继承方法：

1. instanceof: a.instanceof Object
2. isPrototypeOf: Object.prototypeOf(a)

## 经典继承：

在子类的构造函数内部调用父类的构造函数
缺点：函数复用不可用，父类中的方法对子类也是不可见的。

## 组合继承：

使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承
缺点：调用了两次构造函数 （一次在创建子类型原型的时候，另一次在子类的构造函数内部）

## 原型链继承

将子类的原型对象指向父类的实例 child.prototype = new Parent()
Object.create()实现了原型链继承 两个参数：新对象的原型对象，为新对象定义额外属性的对象 eg.Object.create(person,{name:{value:"aa"}})

## 寄生式继承

是创建一个封装了继承过程的函数，在函数内部添加方法和属性，再返回该对象
缺点：使用寄生式继承给对象添加函数，不能做到函数复用

## 组合寄生式继承

不必为了指定子类型的原型而调用父类的构造函数

const obj = {};
for (let i=0; i<len; i++) {
!obj[arr[i]] && obj[arr[i]] = true && newArr.push(arr[i]);
}
