# v8 内存限制：

v8 在 64 位系统下只能分配 1.4G 内存，在 32 位系统下只能分配 0.7G 内存。
原因是 js 是单线程的，一旦进入垃圾回收，就会阻塞页面其他事件的执行。js 垃圾回收是非常耗时的，执行 1.5G 的垃圾回收可能花费 50ms 到 1s .这就造成了页面卡顿。所以 v8 引擎限制了内存。

# 主垃圾回收（并发标记，增量标记，辅助清理）

解决了垃圾回收在主线程上执行，一次执行完整的垃圾回收流程，造成的主线程卡顿。

# 新生代老生代内存回收

新生代是临时分配的内存，存活时间短。
老生代是常驻内存。老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。
v8 的堆内存是 新生代内存+老生代内存

## 新生代内存回收

会将新生代内存分成两个空间 form 和 to

垃圾回收时先检查 form 中是否有存活对象，如果有就按顺序存到 to 中，不存活的对象就被回收。然后再进行 form 和 to 的对调，检查 to 中是否有存活的对象放到 form 中，如此反复。
放入 to 中的对象是按顺序放的，堆内存是开辟的连续的空间，这零散的空间是不够对象去分配的。所以新生代算法会对这内存碎片进行整理，整理出一整块大的内存空间。

## 老生代内存回收

如果新生代中的变量被多次回收依然存在，就会被放到老生代内存中。（已经经历过两次新生代回收的，或者 to 空间内存占用超过 25%的）

1. 进行标记清除(通过 GCroot 标记活动对象和非活动对象)，先会遍历堆内存中所有的变量进行标记，如果有正在使用的或者强引用的就会取消标记。
2. 对非活动对象的内存进行清除，统一清理内存中所有被标记为可回收的对象。
3. 进行碎片整理。在进行清除之后会出现零碎的地址，这些空间被称为内存碎片。这时候如果需要一大块连续的地址空间就不够了，所以就需要碎片整理。在清除阶段结束后，会把存活的对象往一边清理，就是移动对象的过程。

# 增量标记

是把老生代的标记任务，分成很多小部分进行完成，每做完一个小的部分就"歇"一下，就 js 应用逻辑执行一会儿，然后再执行下面的部分，如此循环，直到标记阶段完成才进入内存碎片的整理上面来。

## v8 是如何执行一段代码的

https://mp.weixin.qq.com/s/E-c9gsk-kxIwnwY4R5z_3Q

1. 初始化基础环境
2. 首先通过词法分析和语法分析生成抽象语法树（AST）和作用域
3. 将 AST 转换成字节码
4. 由解释器逐行执行字节码。监听热点代码，遇到热点代码，启动编译器进行编译，然后存起来，优化执行效率
