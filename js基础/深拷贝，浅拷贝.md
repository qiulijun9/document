# js 中分为基本类型和引用类型的值

基本类型包括：number,string,boolean,undefined,null,symbol,Bigint
引用类型的值包括：Object,Array,Function,Set,Map,Date,RegExp,Error

基本类型的值存储在栈中，引用类型的值存储在堆中
浅拷贝拷贝的是值，深拷贝拷贝的是地址

```
b拷贝a的值，修改后不会影响a的值
let a = 'a'
let b = a
b = 'b'
a --- 'a' b---'b'
```

```
深拷贝之后，修改拷贝之后的值，之前的值也变了
let obj1 = {a:1};
let obj2 = obj1;
obj2.a = 2;
console.log(obj1); //{a:2}
console.log(obj2); //{a:2}
```

# 实现浅拷贝的方法

## Array 只能实现一维数组的拷贝

[].concat()、Array.from() ,[].slice()

```
let arr = [1,2,3,4]
let arr2 = arr.slice()
console.log(arr2)//[1,2,3,4]
console.log(arr === arr2)false
```

```
let arr1 = [{a:'1'},{b:'2'},{c:'3'}]
let arr = arr1.concat()
arr[0].a = "a"
console.log(arr１)//[{a:'a'},{b:'2'},{c:'3'}]
```

## Object 只能实现一维对象的拷贝

Object.assign()

```
//只能拷贝第一层属性
let a = {name:"aa",age:12,work:{first:"aa"}}
let b = Object.assign({},a)
b.name = "bb"
b.work.first = "bb"
console.log(b)//{name:"bb",age:12,work:{first:"bb"}}
console.log(a)//{name:"aa",age:12,work:{first:"bb"}}
```

### Object.assign()　注意

让传入的第一个参数为空时，则原对象不发生改变

```
let obj ={x:1,y:2}
let obj2=Object.assign({},obj,{a:3})
console.log(obj) //{x:1,y:2}
console.log(obj2)//{x:1,y:2,a:3}
```

## 扩展运算符 ...

和 Object.assign()拷贝的结果一样

```
let obj = {a:1,b:{c:1}}
let obj2 = {...obj};
obj.a=2;
obj.b.c = 2;
console.log(obj); //{a:2,b:{c:2}}
console.log(obj2); //{a:1,b:{c:2}}
```

# 实现深拷贝的方法

1. JSON.stringify 将对象转换成字符，在用 JSON.parse 转换成对象

```
let obj1 = {
    a:1,
}
let str = JSON.stringify(obj1)
let obj2 = JSON.parse(str)
console.log(obj2); //{a:1}
obj1.a = 2
console.log(obj1); //{a:2}
console.log(obj2); //{a:1}
```

2. loadsh
   \_.cloneDeep
3. jQuery
   var object = \$.extend({}, object1, object2);

# JSON.stringify 的弊端

1)undefined,函数，symbol 作为对象属性值时 JSON.stringify()忽略他们

```
const data = {
  a: "aaa",
  b: undefined,
  c: Symbol("dd"),
  fn: function() {
    return true;
  }
};
JSON.stringify(data)
{"a":"aaa"}
```

2)undefined,函数，symbol 作为数组元素时 JSON.stringify()会将他们转成 null

```
const data3 =[1,undefined,Symbol('b'),function A(){console.log(w)}]
JSON.stringify(data3)
[1,null,null,null]
```

3)JSON.stringify 单独转 undefined,函数，symbol 时，会转成 undefined

```
JSON.stringify(function a (){console.log('a')})
// undefined
JSON.stringify(undefined)
// undefined
JSON.stringify(Symbol('dd'))
// undefined
```

4)转 Date 不能转成 Date 对象

```
JSON.stringify(new Date())
"2020-03-27T17:21:41.471Z"
```

5)布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。

```
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// "[1,"false",false]"
```

6)正则对象会转换成空对象

```
JSON.stringify(/foo/) // "{}" 7) 8)
```

7)JSON.stringify 方法会忽略对象的不可遍历属性

```
var obj = {};
Object.defineProperties(obj, {
  'foo': {
    value: 1,
    enumerable: true
  },
  'bar': {
    value: 2,
    enumerable: false//不可遍历
  }
});

JSON.stringify(obj); // {"foo":1}
```

# JSON.stringify(value [, replacer [, space]])

第二个参数 replacer（自定义函数，可以改变 JSON.stringify 的行为）
第三个参数　 space 就是格式化输出，最大值为 10，非整数时取值为 1

# Object.defineProperties()

功能：主要在一个对象上定义一个或者多个新的属性，或修改现有属性，并返回该对象
语法：Object.defineProperties(obj,props)

```
let obj = {}
Object.defineProperty(obj, 'name', {
    configurable: false,//能否通过delete属性删除此属性
    writable: true,//能否修改属性的值
    enumerable: true,//能否遍历
    value: '张三'
})
console.log(obj)//{name: "张三"}

```

## 设置属性不可遍历

```
let obj = {}
Object.defineProperties(obj, {
    a: {
        value: 1,
        enumerable: false
    },
    b: {
        value: 2,
        enumerable: true
    },
    c: {
        value: 3,
        enumerable: false
    }
})

for(let key in obj){console.log(key)} //b
```

## 设置能否修改此属性

```
let obj = {}
Object.defineProperties(obj, {
    a: {
        value: 1,
        writable: false
    },
})

obj.a = "b"
console.log(obj)//{a:1}
```

//实现深拷贝
function clone(source){
 let target = {};
 for(let i  in source){
   if(source.hasOwnProperty(i)){
     if(typeof source[i] === "object"){
        target[i] = clone(source[i])
     }else{
        target[i] = source[i];
     }
   }
 }
}