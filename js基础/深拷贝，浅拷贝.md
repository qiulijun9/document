# js 中分为基本类型和引用类型的值

基本类型包括：number,string,boolean,undefined,null,symbol,Bigint
引用类型的值包括：Object,Array,Function,Set,Map,Date,RegExp,Error

基本类型的值存储在栈中，引用类型的值存储在堆中
浅拷贝拷贝的是值，深拷贝拷贝的是地址

```
b拷贝a的值，修改后不会影响a的值
let a = 'a'
let b = a
b = 'b'
a --- 'a' b---'b'
```

```
深拷贝之后，修改拷贝之后的值，之前的值也变了
let obj1 = {a:1};
let obj2 = obj1;
obj2.a = 2;
console.log(obj1); //{a:2}
console.log(obj2); //{a:2}
```

# 实现浅拷贝的方法

## Array 只能实现一维数组的拷贝

[].concat()、Array.from() ,[].slice()

```
let arr = [1,2,3,4]
let arr2 = arr.slice()
console.log(arr2)//[1,2,3,4]
console.log(arr === arr2)false
```

```
let arr1 = [{a:'1'},{b:'2'},{c:'3'}]
let arr2 = [{d:'1'},{e:'2'},{f:'3'}]
let arr = arr1.concat(arr2)
arr1[0].a = "a"
console.log(arr)//[{a:'a'},{b:'2'},{c:'3'},{d:'1'},{e:'2'},{f:'3'}]
```

## Object 只能实现一维对象的拷贝

Object.assign()

```
//只能拷贝第一层属性
let a = {name:"aa",age:12,work:{first:"aa"}}
let b = Object.assign({},a)
b.name = "bb"
b.work.first = "bb"
console.log(b)//{name:"bb",age:12,work:{first:"bb"}}
console.log(a)//{name:"aa",age:12,work:{first:"bb"}}
```

## 扩展运算符 ...

和 Object.assign()拷贝的结果一样

```
let obj = {a:1,b:{c:1}}
let obj2 = {...obj};
obj.a=2;
obj.b.c = 2;
console.log(obj); //{a:2,b:{c:2}}
console.log(obj2); //{a:1,b:{c:2}}
```

# 实现深拷贝的方法

1. JSON.stringify 将对象转换成字符，在用 JSON.parse 转换成对象

```
let obj1 = {
    a:1,
}
let str = JSON.stringify(obj1)
let obj2 = JSON.parse(str)
console.log(obj2); //{a:1}
obj1.a = 2
console.log(obj1); //{a:2}
console.log(obj2); //{a:1}
```

JSON.stringify 的弊端
　１）如果 obj 中有时间对象，那 JSON.stringify 的结果只是字符串的形式，不是对象的形式
　２）如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor
　３）如果 obj 里有 RegExp(正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象
　４）如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失；

2. loadsh
   \_.cloneDeep
3. jQuery
   var object = \$.extend({}, object1, object2);
