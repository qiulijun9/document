# 性能优化

网络层面的优化

1. DNS 优化解析

   - dns-prefetch 采用 dns 查找

   ```js
   <link rel="dns-prefetch" href="https://fonts.hellorf.com">
   ```

   - preconnect 在请求该资源前 preconnect 会建立与服务器的连接，如果站点采用的是 https,则此过程包括 DNS 解析，建立 TCP 连接以及执行 TLS 握手，以此来减少请求的延迟

   ```js
   <link rel="dns-prefetch" href="https://fonts.hellorf.com">
   <link rel="preconnect" href="https://fonts.hellorf.com">

   ```

2. http 响应阶段的优化

   - Css/JS 合并打包,可以使用 webpack 等来进行打包
   - 图片大小优化
     小图标可以使用 iconfont,
     使用 base64 的图片直接嵌入在 src 中
   - three-shacking
   - 路由，组件的懒加载
   - 开启 gzip/brotli 压缩

3. 请求数量的优化

   - 合理使用缓存,和本地存储
   - 合理的合并接口
   - 减少/延迟不关键的请求

缓存层面的优化

1. 浏览器缓存
   协商缓存： catch-control ,expires
   强缓存： Etag, last-modified
2. memory catch /disk cache
   内存中的缓存,浏览器会把一些小的文件如 base64，css,js 等放入 memory catch，但是存储空间有限，如果文件过大可能会放入 disk cache 中

3. 引入 web work 进行一些复杂的计算
   独立于主线程之外的 js 线程
4. 使用 CDN

渲染层面的优化

1. 服务端渲染
   由服务器端生成 dom 内容,返回渲染后的 html 给浏览器端,浏览器不需要重新再渲染 html.如果渲染的压力过大时,可能会不建议放在服务器端做渲染.解决了首屏渲染慢的问题,但也增加了服务器的压力.
2. css 使用时的注意
   避免使用通配符选择器
   可以通过继承属性,避免重复定义
   减少选择器的嵌套
   把 css 放到 header 标签中,尽早的执行
3. js 的异步加载方式
4. dom 操作的优化
   减少 dom 的操作,因为在进行 dom 操作的时候要进行重流和重绘,要进行一个长时间的绘制过程.
5. 减少页面的重流和重绘
6. 首屏优化
   当数据多时，先渲染首屏 ，再下滑加载第二屏的数据,图片懒加载
7. 减少 http 请求
8. 对高频事件进行防抖和节流

## 首屏渲染优化

1. 加入 loading 提示
2. 懒加载
3. div 占位

## 性能优化,懒加载脚本

由于 js 文件加载的时候会阻塞渲染,所有一般会把 js 文件放在 body 标签底部

如果要放在<head>中:
defer(延迟脚本) : 确定该脚本不会改变 dom ,可以同其他文件(html)并行下载,在页面加载完之后(window.onload),再加载 js 代码 (立即加载,延迟执行,相当于把 script 标签放在 body 底部)

<script type="text/javascript" src="test.js" defer></script>

async(异步脚本):可以同其他文件(html)并行下载,不依赖 dom 时使用. 区别 defer 是下载完后自动执行, defer 要等到页面加载完后才执行,多个 async 加载的 js 文件,顺序可能会不一致,因为是异步加载的.

<script type="text/javascript" src="test.js" async></script>

# css 加载性能优化 loadcss

将首屏加载的 css 放在页面头部加载,其他模块的 css 使用异步加载
常见的引用

<link rel="stylesheet" href="styles/main.css">

异步加载的引用

<link rel="preload" href="styles/index.css" as="style" onload="this.rel='stylesheet'">
as:指定加载内容的类型, 属性支持的资源: font,image, object,style,script
onload 属性,是指在加载完成之后应用css
