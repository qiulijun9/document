# 函数防抖

当触发事件后，n 秒执行一次，如果 n 秒内被重复触发，则重新计算
例如，keyDown,keyUp, OnClick 窗口的 resize ,scroll 等

```
## 函数防抖
 function debounce(fun, delay, immediate) {
    let timer = null;
    let result;
    function debounced() {
      let self = this;
      let args = arguments;

      if(timer) clearTimeout(timer);
      if(immediate){
        //是立即执行
        //如果执行过，不再执行
        let callNow = !timer;
        timer = setTimeout(() => {
           timer = null;
        }, delay);
        if(callNow) result = fun().apply(self,args);
      }else{
        //没有执行
        timer = setTimeout(() => {
         result = fun().apply(self,args);
        }, delay);
      }

      return result;
      
    }
    debounced.cancel = function() {
      clearTimeout(timer);
      timer = null;
    };
    return debounced;
  }

  function handleKeyDown() {
    console.log("keydown");
  }

  <input
  style={{ height: "50px" }}
  onKeyDown={debounce(handleKeyDown, 1000)} ></input>
```

# 函数节流

高频事件触发，但在 n 秒内只会执行一次

```
function throttle(fun, delay) {
    let timer = null;
    let canRun = true;
    function throttled() {
      let self = this;
      let args = arguments;
      if (!canRun) return;
      canRun = false;
      timer = setTimeout(() => {
        fun.apply(self,args);
        canRun = true;
      }, delay);
    }
    throttled.cancel = function() {
      clearTimeout(timer);
      timer = null;
      canRun = true;
    };

    return throttled;
  }

  <input
  style={{ height: "50px" }}
  onKeyDown={debounce(throttle, 1000)} ></input>
```
