# 函数防抖

当触发事件后，n 秒执行一次，如果 n 秒内被重复触发，则重新计算
比如输入框输入时发请求，用户重复点击按钮时发请求，可以用防抖来节约资源，
拖动窗口时触发的事件resize


```
## 函数防抖
 function debounce(fun, delay) {
    let timer = null;
    function debounced(){
      let self = this;
      let args = arguments;
      if(teimer){ clearTimeout(timer)};
      timer = setTimeout(()=>{
        fun.apply(self,args)
      },delay)
    }
    debounced.cancel = function() {
      clearTimeout(timer);
      timer = null;
    };
    return debounced;
  }

  function handleKeyDown() {
    console.log("keydown");
  }

  <input
  style={{ height: "50px" }}
  onKeyDown={debounce(handleKeyDown, 1000)} ></input>
```

# 函数节流

高频事件触发，但在 n 秒内只会执行一次
 例如：滚动的时候不必每次滚动都触发，做放大镜功能，不必每次移动都计算位置，鼠标不断点击触发（节流让单位时间内只触发一次）

```
function throttle(fun, delay) {
    let timer = null;
    let canRun = true;
    function throttled() {
      let self = this;
      let args = arguments;
      if (!canRun) return;
      canRun = false;
      timer = setTimeout(() => {
        fun.apply(self,args);
        canRun = true;
      }, delay);
    }
    throttled.cancel = function() {
      clearTimeout(timer);
      timer = null;
      canRun = true;
    };

    return throttled;
  }

  <input
  style={{ height: "50px" }}
  onKeyDown={debounce(throttle, 1000)} ></input>
```
