# 为什么要有事件循环机制

因为 js 是单线程的，要想在单线程的执行过程中执行更高优先级的任务，就需要引入事件循环机制。
为什么 js 要设计成单线程的，由于 js 是与用户进行交互的一门语言，如果用户在执行一个进程把该 dom 删除了，另一个进程要去操作这些 dom,这样就容易引发一些问题。

事件循环机制是指在执行宏任务的过程中，如果遇到了微任务，会将其添加到微任务队列中，在该次宏任务执行完毕之后，会依次执行微任务队列中的任务，如果遇到了宏任务则添加到下次的宏任务队列中，依次循环。
由宿主（浏览器）发起的任务（比如 settimeout)是宏任务，由 js 引擎发起的任务是微任务。js 引擎等待宿主环境给它分配宏任务，这段时间需要事件循环机制。
宏任务中可能会有 promise 发起的异步任务，为了保障这些异步任务都在同一个宏任务中执行，所以每个宏任务中会有一个微任务队列，从而可以进行事件轮询。

# 两种任务

异步任务分为宏任务和微任务：

## 宏任务

常见的宏任务：主线程的任务 ,setTimeout,setInterval,setTmmediate，I/O,messageChannel

主线程执行的宏任务主要有：

1. 渲染事件
2. 用户交互事件
3. js 脚本执行
4. 网络请求，文件读写等

宏任务的执行过程：

1. 从多个消息队列中选取了最老的任务
2. 然后循环系统记录任务开始的时间，并把这个任务设置成当前正在执行的任务
3. 任务执行完之后，删除该任务，并从消息队列中删除
4. 统计该任务所有执行的时间

## 微任务

常见的微任务：promise.then ,await 之后的内容,MutationObserver，process.nextTick(nodejs)，v8 垃圾回收过程

微任务就是一个需要异步执行的任务，执行时机是在主函数执行之后（会检查一下微任务队列会按顺序执行），当前宏任务结束之前。v8 会把需要执行的微任务加到微任务队列

产生微任务的两种方式：

1. MutationObserver
   用 MutationObserver 来监听 Dom 节点，当这个节点发生改变（删除或新增节点），就是产生 dom 变化记录的微任务，
   发展：
   -- 早期利用 setTimeout 或 setInterval 来循环监听 dom 的改变
   -- 2000 年提出了 Mutation Event， 采用了观察者的设计模式，当 dom 发生改变就会触发相应的事件，这种方式属于同步回调。 但这种方式，只要 dom 一变就会触发，这样会有严重的性能问题，造成页面卡顿。
   -- MutationObserver API 可以监听 dom 的变化，属性的变化，节点增删，内容变化。MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，利用数据结构来保存 dom 操作的变化，节省了开销。
2. 使用 Promise,调用 Promise.resolve() 和 Promise.reject() 的时候都会产生微任务

## 任务执行的顺序：

首先我们分析有多少个宏任务；
在每个宏任务中，分析有多少个微任务；
根据调用次序，确定宏任务中的微任务执行次序；
根据宏任务的触发规则和调用次序，确定宏任务的执行次序；
确定整个顺序。

### 为什么要引入微任务，只有宏任务不行吗

JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景（因为某些任务执行时间长而阻塞应该在该时机执行的任务），宏任务是先进先出的队列，有更高优先级的任务没有办法优先执行。微任务可以在实时性和效率之间做一个有效的权衡。

1. 执行微任务时不会导致栈的无限扩张
2. 微任务依然会在当前任务执行结束之前被执行，这意味着在当前的微任务执行完之前是不会再执行消息队列中的任务的。
3. 微任务是一个需要异步执行的函数，执行时机在主函数执行结果之后，当前宏任务执行结束之前

# Node 中的事件循环

https://juejin.im/post/5aae19b36fb9a028de447c33

node 执行的阶段：

1. timers callback:检查定时器如果到了 timer，就执行回调。（setTimeout,setInterval）
2. pending callback：执行延迟到下一个循环迭代的 I/O 回调
3. idle, prepare(空闲，预备阶段）: 系统内部使用
4. 轮循阶段(poll): I/O 回调
   异步操作(文件 I/O，网络 I/O)执行完，通知（通过 data,connect 等事件）主线程，使得事件循环到达 poll 阶段
   到达这个阶段后：
   - 执行已到达时间的 timer 回调，将回到 timer 阶段。
   - 如果没有定时器，则执行 poll 队列中的事件
     。 如果队列不为空，则依次执行
     。 如果队列为空
     - 检查是否有 setImmdiate，有则进入 check 阶段,
     - 没有则等待 callback 加入队列
5. check 阶段：执行 setImmdiate 的回调
6. close callback:例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。

浏览器的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段执行的。

# node 中宏任务，微任务与浏览器中的区别

浏览器中的微任务是在每个对应的宏任务之后执行的，而 node.js 中的微任务是在不同阶段执行的

分版本

v10 之前：

1.  执行完阶段中的所有任务
2.  执行 nextTick 队列中的任务
3.  清空微任务队列中的任务

v10 之后与浏览器中的宏任务和微任务执行顺序一样，都是在执行完本次宏任务之后就立即执行微任务队列中的任务
