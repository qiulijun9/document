# 浏览器

主线程执行的任务主要有：

1. 渲染事件
2. 用户交互事件
3. js 脚本执行
4. 网络请求，文件读写等

异步任务分为宏任务和微任务：
宏任务（普通任务队列和延迟队列）：script,setTimeout,setInterval,setTmmediate，I/O,messageChannel
微任务：promise.then,await,MutationObserver，process.nextTick(nodejs)，v8 垃圾回收过程

# 事件机制，

Js 引擎常驻内存，等待宿主把代码传给它再执行。在 Es3 或更远的版本之前，js 没有异步处理的能力，浏览器给它传递什么它就执行什么。在 Es6 之后引入 promise，可以处理异步任务了。

## 宏任务微任务

由宿主（浏览器）发起的任务（比如 settimeout)是宏任务，由 js 引擎发起的任务是微任务。js 引擎等待宿主环境给它分配宏任务，这段时间需要事件循环机制。
宏任务中可能会有 promise 发起的异步任务，为了保障这些异步任务都在同一个宏任务中执行，所以每个宏任务中会有一个微任务队列，从而可以进行事件轮询。
宏任务是执行任务的最小粒度。

### 为什么要引入微任务

JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。

1. 执行微任务时不会导致栈的无限扩张
2. 微任务依然会在当前任务执行结束之前被执行，这意味着在当前的微任务执行完之前是不会再执行消息队列中的任务的。
3.

## 任务执行的顺序：

首先我们分析有多少个宏任务；
在每个宏任务中，分析有多少个微任务；
根据调用次序，确定宏任务中的微任务执行次序；
根据宏任务的触发规则和调用次序，确定宏任务的执行次序；
确定整个顺序。

## eventloop 操作步骤：

1. js 主线程是单线程的 会先执行同步任务
2. 当遇到异步任务时，会区分是宏任务还是微任务并把其放到事件队列中，宏任务放到宏任务队列，微任务放到微任务队列。
3. 继续执行代码，直到同步代码执行完毕。
4. 执行完后，会看微任务队列中有没有微任务，然后按顺序执行完微任务队列中的所有任务，再去宏任务队列中去执行第一个宏任务,回到第一步

# Node

https://juejin.im/post/5aae19b36fb9a028de447c33

node 执行的阶段：

1. 定时器回调阶段(timer):检查定时器如果到了时间，就执行回调。（setTimeout,setInterval）
2. I/O 异常回调阶段：第一段结束后，并不能直接等待异步事件的响应，可以会进入此阶段，比如说 TCP 连接遇到 ECONNREFUSED，就会在这个时候执行回调。
3. 空闲，预备阶段（第二阶段结束，poll 未触发之前）
4. 轮循阶段(poll):异步操作(文件 I/O，网络 I/O)执行完，通知（通过 data,connect 等事件）主线程，使得事件循环到达 poll 阶段
   到达这个阶段后：
   如果有定时器存在，且时间到了，将回到 timer 阶段。
   如果没有定时器，则去看回调函数对列
   。 如果对列不为空，则依次执行
   。 如果队列为空，检查是否有 setImmdiate
   有则进入 check,没有则等待 callback 加入队列
5. check 阶段：执行 setImmdiate 的回调
6. 关闭事件的回调阶段例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。

浏览器的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段执行的。

常见微任务：

1.  process.nextTick
2.  Promise

process.nextTick 执行优先级高于 微任务的执行（promise）

setTimeout: 允许推迟一定时间间隔后运行
setInterval:一段时间间隔之后,重复执行该函数

window.requestAnimationFrame(callback):执行动画,由浏览器执行回调函数.不需要设置时间间隔.
由于 setTimeout 执行的时候可能会有延迟,发生丢帧的现象. 显示器 60Hz 的刷新频率,requestAnimationFrame 一般会根据刷新频率决定的时间,每刷新一次的间隔执行一次回调函数,不会发生丢帧的现象.也不会卡顿.

# setTimeout 是如何实现的？

浏览器遇到 setTimeout 这类 会创建一个延迟执行的消息对列，当遇到 setTimeout 这样的回调函数的时候，会创建一个 回调任务，类似于这样,并把这个任务添加到延迟执行的消息队列中

```js

struct DelayTask{
  int64 id；
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = showName;
timerTask.start_time = getCurrentTime(); //获取当前时间
timerTask.delay_time = 200;//设置延迟执行时间
```

利用事件循环机制，就是在主任务对列的任务执行完毕之后，会调用执行延迟执行消息对列中的任务 , 等该任务执行完之后,继续循环主任务的对列

# setTimeout 的注意事项

1. 如果当前任务执行久，可能会影响定时器任务的执行
   比如，如下，定时器并不会在规定时间执行，它会在循环结束之后才会执行

```js
function bar() {
  console.log('bar')
}
function foo() {
  setTimeout(bar, 0)
  for (let i = 0; i < 5000; i++) {
    let i = 1 + 2
    console.log(i)
  }
}
foo()
```

2. 如果 setTimeout 存在嵌套调用，那系统设置最短时间间隔为 4 毫秒
   是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。
3. 未激活的页面，setTimeout 的延迟时间是 1000 毫秒
4. 延迟时间有最大值的限制，32bit 的最大只能存放的数字是 2147483647 毫秒
5. 不建议在 setTimeout 中设置 this

# requestAnimationFrame 和 setTimeout 工作机制的区别

raf 不需要设置延迟的时间，它是根据系统来决定回调函数的时机，系统会自动调用回调函数来执行动画，所以要比 setTimeout 执行的动画要流畅，因为它不需要等到延迟的时间
会根据系统的刷新频率计算出执行的时间，如果系统的绘制是 60 帧， 执行时间就是 1000 /60 ~ 16.7ms

# 宏任务

宏任务的执行过程：

1. 从多个消息队列中选取了最老的任务
2. 然后循环系统记录任务开始的时间，并把这个任务设置成当前正在执行的任务
3. 任务执行完之后，删除该任务，并从消息队列中删除
4. 统计该任务所有执行的时间

# 微任务

微任务就是一个需要异步执行的任务，执行时机是在主函数执行之后（会检查一下微任务队列会按顺序执行），当前宏任务结束之前。v8 会把需要执行的微任务加到微任务队列

产生微任务的两种方式：

1. MutationObserver
   用 MutationObserver 来监听 Dom 节点，当这个节点发生改变（删除或新增节点），就是产生 dom 变化记录的微任务，
   发展：
   -- 早期利用 setTimeout 或 setInterval 来循环监听 dom 的改变
   -- 2000 年提出了 Mutation Event， 采用了观察者的设计模式，当 dom 发生改变就会触发相应的事件，这种方式属于同步回调。 但这种方式，只要 dom 一变就会触发，这样会有严重的性能问题，造成页面卡顿。
   -- MutationObserver API 可以监听 dom 的变化，属性的变化，节点增删，内容变化。MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，利用数据结构来保存 dom 操作的变化，节省了开销。
2. 使用 Promise,调用 Promise.resolve() 和 Promise.reject() 的时候都会产生微任务
