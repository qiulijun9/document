# 状态码 常用

200              成功,响应体有数据
204              成功，响应头中无数据
206              响应只包含部分内容，使用场景是断点续传，分片下载，带有Content-Range 响应头, eg:Content-Range: bytes 0-99/2000 表示此时获取的是 2000 中的前100个字节

301              永久重定向，此资源不存在，需要用新url访问，响应头中包含Location 指明跳转的url
302              临时重定向, 资源还在，临时用另一个url 访问，响应头中包含Location 指明跳转的url
303              使用 get 方法获取请求资源
304              命中协商缓存，用于If-Modified-Since 缓存控制，重定向到命中的缓存文件

400              客户端发送的报文中存在语法错误
401              没有权限
403              服务器禁止访问该资源
404              资源加载错误
405              服务器禁止该请求方式访问
406              资源无法满足客户端要求
408              请求超时，服务器等待时间太长
409              多个请求发生冲突，多线程并发时的竞态
413              请求报文里的body 太大


500              服务器内部错
501              客户端的请求功能还不支持，“即将开业，敬请期待”
502              网关或代理服务器出错
503              当前服务器忙，无法响应服务 “网络服务正忙，请稍后重试”
504              网关超时


# http 的优缺点
优点：
1. 可靠的传输协议
2. 灵活可扩展
灵活的头部信息
3. 请求 -- 应答的通新方式

# http1.0 
确立了基本的草案
1. 增加了GET 和 POST 方法
2. 增加了状态响应码
3. 引入了http header, 让请求和响应的类型更灵活
4. 引入了协议版本号的概念
5. 传输的数据也不限于文本

缺点：
1. http1.0 规定浏览器与服务器只保持短暂的连接
2. 连接无法复用，每次请求都需要经历三次握手和慢启动
head of line blocking 会导致带宽无法被充分利用，后续健康请求被阻塞

# http1.1
http1.1 的变更：
1. 缓存处理，多了（entity tag,If-Unmodified-since,If-Match,If-None-Match）等缓存信息
2. 长连接：默认开启 connection：keep-alive，弥补了 http1.0 每次请求都要建立连接的缺点
3. 宽带优化及网络连接的使用：http1.0 存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能允许只请求资源的某个部分，返回码是 206
4. 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
5. Host 头处理，请求消息和响应消息中都支持 Host 头域，且请求消息中如果没有 Host 头域，会报 400 错


# http2 和http1.1 相比的优势
1. 头部压缩
采用HPACK 压缩算法，
- 在服务器端和客户端之前建立一张hash 表，将用到的字段存到这张表中，如果传输的是之前的值，只需要传入索引就可以了，请求头字段得到了极大程度的精简和复用
- 对于整数和字符串采用哈夫曼编码，哈夫曼编码是将所有出现的字符建立一张hash 表，经常出现的字符索引尽可能短，使用索引进行传输，从而达到很好的压缩率

2. 支持多路复用
http 队头阻塞：http 基于请求-响应模型，在同一个TCP 连接中，前面的请求迟迟没有响应，会阻塞后面的请求。

①. 支持二进制传送，不再是纯文本
http1.1 请求和响应都是采用报文（Header+body）的形式，http2 采用 二进制帧01传送，方便计算机解析，体积小，传输更快
二进制帧头存放头部信息，Data 帧存放请求体数据，这些不再是完整的http 报文，而是一个一个的分帧，不存在先后顺序，也不会排队等待也就没有了对头阻塞的问题。
通信双方都可以采用二进制传送，这种二进制双向传输的序列，被称为流，用流在一个Tcp 链接上进行多个数据帧的通信就是多路复用。
因为每个帧都有标识属于哪个流，多个帧组成一个流，二进制到达后对方会将Stream ID 相同的二进制帧组成完整的请求和响应报文。

3. 支持服务端推送
服务器端不止是只能被动的接受请求，比如在浏览器请求了一个html ,服务器会将响应的资源都一起返回，减少用户等待的时间

缺点：
http 使用单个TCP 进行多个请求的连接，大文件传输可能会导致网络拥塞
还会出现丢包的现象，有丢包重传的机制，但服务器会等待丢的那个包，造成对头阻塞

# http 3.0
QUIC 协议（快速 UDP 网络连接）。QUIC 放弃了 TCP，而使用了同级的 UDP 协议做传输层。在 UDP 的基础上增加了很多功能，比如多路复用，流量控制，重传等。基于UDP 实现了可靠传输。
UDP 是无连接的，所以就不需要 握手 和挥手 ，所以天生比TCP 快。

http2.0 的二进制传送
缺点：
1. 难读懂  可读性差，调试会带来一定的困难 
2. 容错性差  在网络不稳定的情况下容易发生丢帧的现象，无法保证二进制帧的完整性

二进制卡帧是指：如果一个帧丢失了，那它后面的帧都无法被处理，从而导致整个连接被阻塞

http3.0 可以在不阻塞连接的情况下实现流量控制和拥塞控制（无头部阻塞控制的阻塞控制算法），通过提高网络传输的速度和稳定性，从而避免http2.0 二进制卡帧的现象

# TCP 和 UDP 的区别
1. 连接性： TCP 在通信之前需要你建立链接 ，UDP是无连接的协议，不需要建立连接就可以发送数据
2. 可靠性：TCP 通过确认和重传机制确保数据的完整性和可靠性,UDP 不可靠传输可能造成数据丢失
3. 传输效率L:TCP 需要建立链接，在传输速率上要比UDP低
# http 报文是什么样子？
http 报文分为请求报文和响应报文，由三部分组成：
起始行 + 头部信息 + 空行 + 实体 
起始行+头部信息又称为是请求头或者响应头，消息正文称为实体，一般也叫 Header + body

请求头
1. 请求行：
请求方式 + url(请求目标) + http 协议版本号  eg: GET / HTTP/1.1
2. 头部信息：key:value 的形式，可以自定义添加
eg:
host:127.0.0.1
connection:Keep-alive
3. 空行

响应头：
1. 状态行：
版本号 + 状态码 + 原因 eg: HTTP1.1  200  ok
2. 头部信息响应头
3. 空行

常用的头字段：
分为 4 大类： 
1. 通用字段
date: http 报文创建的时间

2. 请求字段
host: 请求由哪个主机来处理
user-agent: 请求的浏览器

3. 响应字段
server: 提供web服务的软件名称和版本号 eg: sever:nginx

4. 实体字段
content-Length: 规定body 的长度



# http2 二进制帧是如何设计的
二进制帧分为帧头和帧体

帧头
|       帧长度    |
| 帧类型  | 帧标志位 |
|       流标识符    |

帧类型分为数据帧和控制帧，数据帧用来存放http 报文，控制帧来控制流的传输
流标志符 Stream ID，用它来选出相同id的帧组成请求报文/响应报文

帧体
存放实际传输的数据

# 请求头字段
客户端用 Accept 头告诉服务器希望接收到什么数据
服务器端用 Content 告诉客户端实际发送了什么数据 

Accept 
1. 客户端可以理解的头，比如“我能够看懂html,xml,webp和png 的图片”
Accept: text/html,application/xml,image/webp,image/png
2. 客户端支持的压缩格式
Accept-Encoding: gzip, deflate, br 
3. 客户端可理解的自然语言
Accept-Language: zh-CN, zh, en
4. 浏览器请求的字符集
Accept-Charset: gbk, utf-8
5. 还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality
权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。
Accept: text/html,application/xml;q=0.9,*/*;q=0.8



Content
1. 告诉浏览器实际传输的数据格式
Content-Type: text/html
2. 响应数据被压缩的格式
Content-Encoding: gzip
3. 实际返回的数据的语言类型
Content-Language: zh-CN
4. 服务器响应的字符集
Content-Type: text/html; charset=utf-8

# Content-Type （数据格式，浏览器以什么格式读取文件）常见的有哪些
text : 文本格式的可读数据
text/html, charset=utf-8 字符集
text/plain, text/css 等

image: 图像文件
image/png, image/jpeg, image/gif 等

audio/video: 音频和视频
audio/mpeg, video/mp4 等

application: 格式不固定，可能是文本可能是二进制
application/json, application/javascript, application/pdf, application/octet-stream,application/x-www-form-urlencoded 等

# Content-Encoding 压缩方式
gzip: 当今最流行的压缩格式，zip 压缩格式
deflate: 另外一种著名的压缩格式，zib 压缩格式
br: 一种专门为 HTTP 发明的压缩算法

# http 2 特点 和 cdn 有什么关系
cdn 支持 http2,可以在很大程度上缓解传输压力
如果存在 cdn 缓存，当本地缓存过期之后，会先向最近的 cdn 缓存进行查找，如果 cdn 缓存也过期，就会像源站点发出请求返回新的资源。

# 同源站点间的通信

1. localStorage
2. BroadCast Channel 广播通信
   const bc = new BroadcastChannel('AlienZHOU');
   通过 bc.onmessage() 来监听，bc.postMessage() 发送数据

3. Service Worker 长期运行在后台的 worker
   监听消息 navigator.serviceWorker.addEventListener('message', function (e) {})
4. window.open
5. Websocket


# 三次握手
确认双方的发送和接收能力
1. 客户端主动发起连接 发送 SYN,自己变成了SYN-SENT状态。
2. 服务器接收到，返回 SYN 和ACK,自己变成了SYN-REVD 状态
3. 客户端再发送 ACk 给服务器，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。

# 四次挥手
1. 客户端向服务器发送断开信号，发送FIN 报文，自己变成了FIN-WAIT-1状态
2. 服务器端接收并给予客户端响应,响应信息为 ACK=1,因为这时可能还有数据包没有传完,不能立即中断.
3. 客户端接收到了服务端的确认，变成了FIN-WAIT2状态。
4. 服务端再检查数据包传送完之后，提出正式关闭的请求，将 FIN 置为 1
5. 客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。客户端确认关闭连接请求,双方断开连接

# https 是如何让数据传输更加安全的

浏览器和服务器之前传输数据是明文的，这就意味着任何一步都会有中间人来窃取信息

起初是在 Http 和 Tcp 之前建立了一个安全层（SSL/TLS）,所有经过安全层的数据都要经过加密和解密

第一版： 对称加密

- 浏览器向服务器发送对称加密套件列表（浏览器支持的加密方式列表）和 client-random
- 服务器收到后，选择一个对称加密的方式，再把该加密方式和 sever-random 随机数发送给浏览器端
- 这时双方都有了 client-random,server-random,加密方式，然后双方会通过这两个随机数生成一个密钥，来使用该密钥进行加密解密

缺点： 中间人可以获取到传输的随机数以及使用的加密方式，这样就可以通过密钥来伪造数据了

第二版：非对称加密

- 浏览器发送非对称加密套件列表
- 服务器端接收到列表后会，选择一个加密方式和公钥传输给浏览器端
- 浏览器端使用该公钥加密数据，服务端使用自己的私钥解密
- 服务端只能采用私钥加密，浏览器端使用公钥解密

缺点：非对称加密的计算效率太低， 服务器端的数据不安全，中间人还是会拿到公钥来对数据解密

https（443）https  = http+SSL/TLS
1. 添加数字证书
黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。
浏览器要想服务端证明他自己

- 服务器端并不是直接把公钥传给浏览器端，而是返回了数字证书，数字证书里包含了公钥
- 浏览器端需要验证证书的有效性，通过之后才能就行后序传输,保证客户端和服务器端的通信安全

2. 非对称加密和对称加密的结合

- 浏览器端向服务器端发送加密套件列表，非对称加密套件列表，client-random
- 服务器端向服务器端发送选择后对称和非对称加密的方式，server-random 和公钥
- 浏览器端接收，并生成随机数 per-master ,再利用公钥加密发送给服务器
- 服务器端根据私钥解密 per-master
- 现在双方都有 client-random,server-random,per-master ,然后利用这三个随机数生成密钥进行传输

# SSL/TLS
SSL/TLS 安全套阶层（安全通信协议）
“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法” ：“ECDHE-RSA-AES256-GCM-SHA384”。
TLS 的握手过程：

第一阶段： 客户端/服务器端共享 client-random ,server-random,server-params
1. 客户端---》服务端 发送版本号，加密套件，client_random
2. 服务端 ---》 客户端 ：版本号，选择后的加密列表，sever_random
3. 客户端 ---》 服务端：服务端证书
4. 客户端 ---》 服务端：发送公钥，私钥签名

第二阶段：证书验证

第三阶段： 主秘钥生成
1. 客户端和服务端 分别使用client_random、sever_params  计算出随机值per-master
2.  客户端和服务端 用client_random、server_random、pre_master 生成一个随机数作为秘钥
3. 客户端和服务端 试着发送数据加密一下，服务端做验证，双方加密解密都ok ,握手结束



# 缓存

缓存分为强制缓存和协商缓存

强制缓存：不需要向服务端发送请求，直接是读取本地存储，也不需要域名解析和 tcp 链接，强制缓存在 http 中的状态码是 200
主要通过 Expires,Catch-Control （响应头）几个属性来控制
1. Expires :过期时间，会根据系统时间和 Expires 来判断是否过期，但是系统时间有可能不准确（本地时间）
2. Catch-Control : 优先级高
- max-age: 单位是秒，是指从请求发起到缓存失效的时间，指强缓存失效的时间 eg: max-age=30 
- no-store: 不使用缓存
- no-catch:需要询问服务端缓存是否有效，有效返回 304，无效返回新的资源
- must-revalidate：缓存不过期就可以使用，过期了就要去服务器验证
- s-maxage=<seconds>：和 max-age 类似，但它只针对代理服务器缓存有效，（只有响应被代理服务器缓存时缓存才会生效），s-maxage的优先级更高，s-maxage用于控制共享缓存的时间，max-age 适用于所有的缓存

- public: 响应可以被中间代理，cdn 等去缓存，允许客户端和代理服务器缓存
- private: 个人缓存，中间代理，cdn 不允许缓存。只允许客户端缓存


Pragma:no-catch 同 catch-control 的 no-catch 一样，不使用强制缓存,历史遗留字段，兼容http1.0

协商缓存：在没有命中强制缓存的情况下会走协商缓存
在请求头设置了 if-Modified-Since 或 if-None-Match 时，服务端会查看是否命中缓存，命中会返回 304，并在响应头设置 Last-Modified 和 ETag 属性

1. Last-Modified/if-Modified-Since:代表文件的最后修改时间
在第一次请求时，服务端会在响应头中设置 Last-Modified。
在第二次请求时浏览器会携带 if-Modified-Since 为上次服务端返回的响应值。
服务端会根据最后修改时间 If-Modified-Since 做对比，如果相同就返回 304，不同则返回新资源

2. ETag/if-None-Match : 代表文件的唯一 hash 值，只有文件发生改变的时 hash 值才会改变

Ctrl+F5 强制刷新  ,请求头中不会有if-None-Match 而且Catch-Control：no-catch，返回新的数据200 而不是304
点击浏览器的前进和后退会读取缓存里的内容

# 输入 url 到页面渲染

1. 浏览器缓存
   查看是否命中强制缓存，如果命中直接使用缓存中的内容，如果不命中则从网络中获取。

2. 域名解析---把域名解析成ip，获取ip地址和端口号
   查看是否有缓存，如果有缓存直接使用缓存中的 ip 地址
   由于数据包是通过 ip 地址传给对方的，所以需要域名解析。域名解析就是把域名解析成 IP 地址的过程
   浏览器提供了 DNS 数据缓存功能，如果域名已经被解析过，就不用再进行域名解析，会直接使用缓存里的
   优先级：浏览器缓存-->本地hosts--->系统缓存--->根域名--->顶级域名--->权威域名--->非权威域名   如果没有找到，会出现dns 解析错误

3. 浏览器使用 TCP  和服务器建立连接

- 三次握手： 确认客户端和服务端的接收和发送能力都正常
- 发送数据：接收端在接收到数据之后必须向发送端发送确认信号来保证数据没有丢包
- 四次挥手： 通过四次挥手来断开连接

4. 发送 http 请求
   请求包括：请求行，请求头，空行，请求体
   常见的请求头包括：
   Cache-Control, Expires,if-Modified-Since,Accept,Accept-Encoding,Accept-Language,Connection,Cookie,Host
   http1.0
   短连接
   http1.1

   - 长连接
   - 缓存的头部字段
   - 宽带优化及网络连接的处理
   - 错误通知管理，新增了错误状态码
   - host 头处理

   http2.0

   - 支持二进制传送
   - 多路复用
   - 支持服务端推送
   - 头部压缩

5. 服务器返回拼接好的报文
    发送请求到服务端之后，服务端会给予响应，响应包括：响应行，响应头，响应体

6. 渲染页面
  解析 
   - 构建 dom 树 （由于浏览器无法直接识别html）
     将html 转化成Dom 树结构， 利用 token 解析成 dom 树 挂载到 document 上

   - 构建 CSSOM 树，计算出dom 节点的样式
     收集 css 规则:
      1 link标签引用
      2 style标签中的样式
      3 元素的内嵌style属性
    将这些css 转换成styleSheets 对象

   - 生成布局树 （确定元素的位置）
     给 dom 树添加位置信息

  渲染

   - 分层（构建图层树）
     每层中样式的绘制不会影响到其他层
     显示合成
     1. 层叠上下问节点
     position不为static并且设置了z-index ， opacity 值不是 1 ,元素的 transform 值不是 none
     2. 需要剪裁的地方

   - 生成绘制列表
     生成图块

   - 栅格化
     把图块转成位图的过程。
     浏览器是多进程的：网络进程，渲染进程，浏览器进程，插件进程，GPU 进程
     渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据。
   - 展示
    合成线程发送DrawQuad 绘制指令。浏览器进程根据消息生成命令展示到显示器上
7. 断开连接


# 页面渲染从空白页面到渲染完成可以做哪些优化

网络方面
1. 减少 HTTP 请求：将多个 CSS、JavaScript 文件合并成一个文件，使用 CSS Sprites 来减少图片文件的数量。
2. 使用 CDN：将静态资源存放在 CDN 上，加快资源加载速度。
3. 使用浏览器缓存：使用缓存来避免重复加载资源，减少 HTTP 请求次数。
4. 压缩资源：压缩 CSS、JavaScript 和 HTML 文件，减小文件大小，加快资源加载速度。
5. 使用 Gzip 压缩：使用 Gzip 压缩来减小传输的数据量，加快资源加载速度
6. 使用预加载：使用 rel="preload" 属性来预加载页面所需的资源，加快资源加载速度。

html
1. 异步加载：“defer” ，async 将页面中不必要的资源延迟加载，只有当用户需要时才加载，减少资源加载时间。
2. 使用 SSR：使用服务器端渲染（Server-side Rendering）来提前生成 HTML，减少客户端渲染时间。
3. 减少重绘回流
4. 使用 Web Workers：使用 Web Workers 可以将 JavaScript 的计算任务放在后台线程中执行，避免阻塞页面渲染。

# 服务端渲染
根据目录 pages 下的文件去渲染 入口文件 app.js
1. 什么是服务端渲染 (SSR)？
服务端渲染（是指在服务器端将动态页面渲染成 HTML 页面，然后再将其发送到浏览器进行展示的过程。相对于客户端渲染，SSR 可以提高首屏渲染速度，有助于 SEO（搜索引擎优化） 优化等。

2. SSR 的优缺点是什么？
优点：

- 改善首屏渲染速度，提高用户体验
- 有利于优化 SEO，提高网站的搜索排名
- 对于低性能的设备，SSR 可以提供更好的用户体验
缺点：
- 对于动态交互较多的应用不太友好
- 对于大量的请求和并发访问的情况，会增加服务器的负担

3. SSR 的实现方式有哪些？
传统的后端渲染（如使用 JSP、PHP 等技术）
基于 Node.js 的渲染框架（如 Next.js、Nuxt.js 等）

4. SSR 和 CSR 的区别是什么？
SSR 是在服务器端将动态页面渲染成 HTML 页面，然后再将其发送到浏览器进行展示的过程，而 CSR 是在浏览器端通过 JavaScript 来渲染页面。
SSR 可以改善首屏渲染速度，有利于 SEO 优化等，但对于动态交互较多的应用不太友好；CSR 可以提供更好的用户交互体验，但可能会影响网页的 SEO。
SSR 的实现方式有传统的后端渲染和基于 Node.js 的渲染框架等，而 CSR 的实现方式则主要是通过各种前端框架和库来实现。