# webpack 中的 Module 是指什么？

webpack 支持 ESModule,CommonJs,AMD ,资源等模块

1. ES Module
   export ,import 引入和导出资源

   ```js
   import { a } from './a.js'

   export { b }
   ```

2. CommonJS
   导入，导出

```js
require

module.exports
```

# package.json

设置 type:module 使用 ES module

# webpack 中的 module ,怎么表示依赖关系

主要根据每个文件中的 引入语句来，确定依赖了哪些文件,再打包出相应的 bundle
如 import, require , define require ,@import ...

# webpack 中的 chunk 和 bundle 的区别是什么

1. chunk（打包过程中）
   chunk 是 webpack 打包过程中的 modules 集合，是打包过程中的概念

   如何形成的 chunk？
   webpack 打包是从入口文件开始，入口文件引入其他模块，其他模块引入另外的其他模块，webpack 通过引用关系打包模块，这些 modules 就形成了一个 chunk,

   多入口的模块，会产生多个路径，会形成多个 chunk

2. bundle
   最终输出的一个或多个打包好的文件

3. chunk 和 bundle 有什么关系

- 一般一个 chunk 对应一个 bundle,
- 但是 在 devtool: 'source-map',是会产生一个 chunk 对应两个 bundle 的情况

- 多个入口也会打包出不同的多的 chunk 和 bundle

```
  entry: {
    index: ['./src/index.js', './src/add.js'],
  },
```

会打包出一个 chunk, 会把一个 key 数组中的文件合并成一个入口

```
 entry: {
    index: './src/index.js',
    add: './src/add.js',
  },
```

不同的 key 对应的入口文件会形成不同的 chunk

chunk 是过程中的代码块，bundle 是打包输出的代码块，chunk 在构建完成就形成了 bundle

4. split chunk

# plugin 和 loader 分别是什么，怎么工作的？

1. Loader 模块转换器
   将非 js 模块转换成 webpack 能识别的 js 模块
   webpack loader 将所有类型的文件，转换成应用程序的（依赖图）可以直接使用的模块

2. Plugin （扩展插件）
   运行在 webpack 打包的各个阶段,webpack 都会广播出对应的事件，插件监听对应的事件

3. Compiler（webpack 实例）
   包含了 webpack 环境的所有配置信息（options,loader,plugins），是在 webpack 启动时实例化的，可以理解为 webpack 的实例，是全局唯一的
4. Compliation
   包含了当前的模块资源，编译生成资源
   webpack 在开发模式下运行的时候，每当检测到一个文件发生变化，就会生成一个 Compliation

# webpack 的打包过程

1. 初始化参数：初始化 webpack.config.js 中的参数
2. 开始编译： 初始化一个 Compiler 对象，加载所有配置，开始编译
3. 确定入口： 根据 entry 找出所有的入口文件
4. 编译模块： 从入口文件开始，调用 loader，递归寻找依赖
5. 完成编译：得到每个模块编译好的内容，以及各个模块之前的关系
6. 输出资源：根据依赖关系，组装成一个个包含多个 module 的 chunk
7. 输出完成： 确定输出的文件名

# webpack 常见的 plugin

html-webpack-plugin: 解析 html，并自动引入 css,js 文件
DefinePlugin：编译时配置全局变量
HotModuleReplacementPlugin：热更新
happypack: 多进程打包
clean-webpack-plugin：清理上次打包没有使用的文件
optimize-css-assets-webpack-plugin:css 去重
speed-measure-webpack-plugin：输出打包的耗时
webpack-bundle-analyzer：可视化输出打包文件的体积

# webpack splitChunk

webpack 4 ,对引入到公共的文件会打包到 common.js 中

```js
optimization: {
  splitChunks: {
     chunks: "async", // 必须三选一： "initial" | "all"(推荐) | "async" (默认就是async)
     minSize: 30000, // 最小尺寸，30000
     minChunks: 1, // 最小 chunk ，默认1
     maxAsyncRequests: 5, // 最大异步请求数， 默认5
     maxInitialRequests : 3, // 最大初始化请求书，默认3
     automaticNameDelimiter: '~',// 打包分隔符
     name: function(){}, // 打包后的名称，此选项可接收 function
     cacheGroups:{ // 这里开始设置缓存的 chunks
         priority: 0, // 缓存组优先级
         vendor: { // key 为entry中定义的 入口名称
             chunks: "initial", // 必须三选一： "initial" | "all" | "async"(默认就是async)
             test: /react|lodash/, // 正则规则验证，如果符合就提取 chunk
             name: "vendor", // 要缓存的 分隔出来的 chunk 名称
             minSize: 30000,
             minChunks: 1,
             enforce: true,
             maxAsyncRequests: 5, // 最大异步请求数， 默认1
             maxInitialRequests : 3, // 最大初始化请求书，默认1
             reuseExistingChunk: true // 可设置是否重用该chunk
         }
     }
  }
 },

```

SplitChunksPlugin 插件来进行公共模块的提取，利用浏览器缓存这些无需频繁变更的代码。

# webpack 热更新实现原理

服务端开启了 express 应用，对 webpack 的编译做监听。
通过 websocket 和浏览器端建立连接，当文件变化，webpack 编译完之后会通过 websocket 通知浏览器，刷新某个模块。
