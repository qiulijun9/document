# class 组件和 function 组件的区别

1. 类组件中有 state,生命周期,this 等，函数组件是无状态的可以通过 hook 来处理
2. 类组件之前逻辑很难复用，函数组件内可以抽出相同的 hook 来做
3. 相同逻辑被拆分在不同的生命周期里，容易引发很多问题，函数组件可以在 useEffect 中统一处理

# react 项目中的优化

- 减少不必要的渲染,减少计算

1. PureComponent,React.memo
   对 props 和 state 进行浅比较,减少子组件的重复渲染。
2. shouldComponentUpdate
   通过对子组件使用的一些属性判断，发生改变才返回 true,能避免子组件重新 render
3. useMemo(),useCallback
   返回一个计算的值，避免依赖不变情况下的重新计算和重新渲染
4. 列表项使用 key
5. 减少 bind,this 的次数
6. hooks 正确依赖
7. 长列表优化,懒加载,React.lazy()

# useMemo 和 useCallback 的区别

useCallback() 返回一个函数，只有在依赖项发生变化的时候才会重新渲染,通常用在父组件传参时,减少子组件渲染的次数，配合 React.memo()使用

useMemo() 返回一个值,减少计算

# useMemo 和 useState 的区别

useState 没有依赖项，state 在每次调用时都会重新计算
useMemo 只有在依赖发生变化了才会重新计算

# 如何获取到 state 最新的值

setState 在 react 生命周期的方法里是异步的
在 setTimeout，或是 中是同步的，可以获取到最新的值
如果是 class 组件，可以在 this.setState 的第二个参数 （回调函数）中获取该值
但如果是函数组件：

1. 可以利用依赖这个 state 来实现
2. setState 的参数可以设置一个值或者是一个回调函数，可以在回调函数中拿到上一次更新的值 setState((preVal)=>preVal+1)
3. 利用 ref 来保存这个变量,那 ref.current 就是最新的 state

```js
function Counter() {
  const [count, setCount] = useState(0)
  const prevCountRef = useRef()

  useEffect(() => {
    setCount(count)
    prevCountRef.current = count
  }, [])

  const handleClick = () => {
    setCount(count++)
    prevCountRef.current = count++
  }

  const prevCount = prevCountRef.current

  return (
    <h1 onClick={handleClick}>
      Now: {count}, before: {prevCount}
    </h1>
  )
}
```

# react 生命周期

componentWillMount: 在渲染之前执行的方法
componentDidMount: 第一次挂载时执行的方法
componentWillReceiveProps:初始化 render 的时候不会执行，会在接收到新的 props 时触发
shouldComponentUpdate: 确定组件是否更新，默认为 true
render:render()
getSnapshotBeforeUpdate: 更新 dom 之前做的一些操作
componentDidUpdate:更新 props,state 触发的方法
componentWillUnMount: 组件销毁时执行的方法

监听 props 变化会在哪个生命周期中？

# 什么是高阶组件，什么场景用到了高阶组件，写过什么高阶组件

高阶组件接收一个组件返回一个新组件的函数，对组件的状态并不会去更改

作用：

1. 逻辑功能共享
2. 属性代理
3. 操作组件实例
4. 渲染劫持,在 wrapComponent 组件中,可以对原来的组件进行，条件渲染，懒加载等

使用场景：
redux 的 connect
react-router withRouter

# react.Fragment react.Node ...的区别

react.Fragment 为了包裹多个元素，不会生成额外的 dom

react 15 之前 render() 返回必须有一个根节点
react 16 render() 允许返回一个数组

react.Node 可以是 react.Fragment,react.element,string,number...等

# 实现异步的几种方案

回调函数
promise
async await
generator

# 快排

```js
function quickSort(arr) {
  if (arr.length < 1) {
    return arr
  }
  let point = Math.floor(arr.length / 2)
  let pointVal = arr.splice(point, 1)[0]
  let left = []
  let right = []

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pointVal) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pointVal], quickSort(right))
}
```

# reduce

```js
Array.prototype.reduceArr = function (fn, initVal) {
  if (Object.prototype.toString.call(fn) !== '[object Function]') {
    console.log('not a function')
  }
  let arr = this
  // 默认索引 如果没传默认值参数 则使用数组的第二项开始
  let initIndex = arguments.length > 1 ? 1 : 0
  // 累计的值 如果没传默认值参数 则使用数组的第一项作为默认值
  let res = arguments.length > 1 ? this[0] : initVal

  for (let i = initIndex; i < arr.length; i++) {
    res = fn(res, arr[i], i, arr)
  }

  return res
}
```

# Object.defaultProperty ,Object.prototype 的使用

Object.defaultProperty 冻结对象
Object.prototype 原型

# call,apply,bind

- call,apply 都是用来改变 this 的指向
  call 必须是一个函数去调用，第一参数是对象，函数的调用者，从第二个参数开始可以接收任意多个数

  apply 必须是一个函数来调用，参数必须是一个数组或是类数组

  使用场景：
  对象的继承
  获取数组中最大值，最小值
  数组合并
  Array.prototype.push.apply(arr1,arr2)

- bind
  创建一个新函数，在调用时设置 this 的指向为传入的值，返回是一个函数，需要调用才执行，apply,bind 是立即执行

# js 数据类型，如何判断类型

基本类型：string,boolean,number,undefined,null,symbol,bigint
引用类型：Object,Array,Function

判断类型：

1. typeof 不能判断引用类型和 null 都会返回 object
2. instance of 不能判断基本类型,但可以判断引用类型和装箱后的基本类型 是基于原型链的实现
3. Object.prototype.toString.call() 类型都可以判断
4. isXXX Array.isArray() isNaN()

# es5 的继承 ，es6 的继承

es5

1. 原型链继承

   将子类的原型对象指向父类的实例

   ```js
   Child.prototype = new Parent()
   ```

   优点：

   - 子类继承父类的属性和方法，和父类的原型对象

   缺点：

   - 不能实现多继承
   - 如果不小心改了父类原型对象引用数据类型的值，之后所有子类实例对象也会改变
   - 创建子类时无法向构造函数传参

2. 构造函数继承

   在子类的构造函数内部通过 call,apply 调用父类的构造函数

   ```js
   function Child() {
     Parent.call(this,...)
   }
   ```

   优点：

   - 解决了原型链继承的所有问题
     可以实现多继承，可向父类传参，解决了原型链继承中子类实例共享父类引用类型的问题

   缺点：

   - 不能继承父类原型链上的属性和方法
   - 实例并不是父类的实例，而是子类的实例
   - 无法实现函数复用,方法都在构造函数中定义，每次创建实例就会创建一遍方法

3. 组合继承
   组合继承是原型链继承和构造函数组合使用的一种方式

   ```js
   Chid.prototype = new Parent()
   Child.prototype.constructor = Child

   function Child() {
     Parent.call(this,...)
   }
   ```

   优点：

   - 可继承父类，以及父类原型上的属性和方法
   - 解决了原型链继承中共享引用数据类型的问题
   - 可传参，可复用

   缺点：

   - 父类的构造函数会被调用两次，第一次是在 new Parent()上，为了继承父类的属性和方法，第二次是在 实例化时调用的构造函数方法 new Child()
   - 生成了两个实例，子类上的属性和方法会覆盖原型上的属性和方法，增加了不必要的内存

4. 寄生组合继承
   通过 Child.prototype = Object.create(Parent.prototype) 来确定 Child.prototype 的指向 Child._proto_ 指向 Parent.prototype

   ```js
   Child.prototype = Object.create(Parent.prototype)
   Child.prototype.constructor = Child
   ```

   是 es5 比较常用的方法

5. 原型式继承
   该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例，本质是一个浅拷贝。 是没有 Object.create 之前的写法

   ```js
   function create(obj) {
     var newObj = {}
     newObj.__proto__ = obj
     return newObj
   }
   ```

6. 寄生式继承

```js
function createAnother(original) {
  var clone = Object.create(original) // 通过调用 Object.create() 函数创建一个新对象
  clone.fn = function () {} // 以某种方式来增强对象
  return clone // 返回这个对象
}
```

es6

7. class 中的 extend 继承
   依靠 extend 和 super ,效果和组合继承一样

   class 通过 extends 继承父类的属性和方法，子类没有 constructor 方法，会默认添加 constructor
   super 的调用代表着父类构造函数

# es5 与 es6 继承的区别

e5 的继承是创建子类的实例对象，再创建父类的方法添加到 this 上（Parent.apply(this）)

es6 先创建父类的实例对象 this(也就是使用 super())，然后再用子类的构造函数修改 this

# 数组 forEach map

相同点
都是循环遍历数组中的每一项 forEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项）、index（索引值）、arr（原数组）

不同点
forEach 没有返回值
map 有返回值 返回一个新数组

# let const var

作用域
变量提升
暂时性死区
重复声明
默认值

# 事件循环机制

https://github.com/qiulijun9/Q-A/issues/1

# 前端的存储

cookie

- 存储大小限制，只有 4k,一般用于验证用户的身份如
- 设置 HttpOnly,防止 cookie 被 js 访问
- cookie 有过期时间，过期自动销毁
- 发起同域下的 http 请求时，都会携带 cookie

localStorage:

- 本地存储，不会过期
- 大小在 5M-10M
- 所有页面都可共享该值

sessionStorage:

- 只存在于当前的会话，当页面关闭或刷新之后数据就会清除

indexedDB:

- 存储空间大，可达到几百 M
- 可以存储二进制

# 跨域解决办法

1. JSONP
   利用<script>发出请求，带着 callback 函数，由服务端传递值，客户端执行回调函数来获取

   缺点：只支持 get 请求，不安全可能会遭到 xss 攻击

2. cors
   浏览器端设置请求头 origin 字段，服务端设置响应头 Access-Control-Allow-Methods， 等

   简单请求，复杂请求

3. postMessage
   postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
4. webSocket 链接后，与 http 协议无关
5. nginx 反向代理

# 作用域

作用域是用来决定代码变量和其他资源的可访问性

分为 全局作用域，函数作用域，块级作用域

全局作用域：在最外层定义的函数，变量，以及未定义直接赋值的变量会提升到全局作用域。

函数作用域：声明在函数内部的变量，一般只在该函数内能访问到

块级作用域：一个函数内部，一个代码块内部
es5 之前是没有块级作用域的，let const 引入的块级作用域 解决 for 循环中 var 的问题

# 原型，原型链

- 什么是原型？

原型：也是原型对象，每个 js 对象在创建的时候就会关联另一个原型对象，并继承共享原型的属性和方法，节省内存。

- js 中每个对象都有一个 _proto_ 属性，这个 _proto_ 属性 会指向对象的原型（即构造函数的 prototype）
- 每个函数都有一个 prototype 属性
- 每个原型都有一个 constructor 属性 指向关联的构造函数 Person.prototype.constructor === Person

- 什么是原型链？
  当查找实例的属性时，如果找不到，就会查找原型对象的属性，如果还查不到会查找原型的原型，一层一层向上查找，直到查到最顶层为止，也就是 Object.prototype,所形成的链条就是原型链

每一个可以被 new 调用的 构造函数 都有一个 prototype 属性 这个属性就是原型的值，比如 实例化 new Array() Array.prototype 就是 Array 实例化后的原型

Function.prototype 为所有对象的原型如 Function、String、Number、Boolean、Array 这几个。
[]._proto_ === Array.prototype
Array.prototype._proto_ === Object.prototype
Object.prototype._proto_ === null

Function.prototype._proto_ === Object.prototype

- 数字 1 有没有原型？
  基本类型的 1 是没有原型的,
  Number() 是一个构造函数, 如果使用 Number(1) 创建的实例 1 是有原型的 Number(1)._proto_ === Number.prototype Number.prototype._proto_ === Object.prototype

# 箭头函数和普通函数的区别

1. 箭头函数没有 this ,在定义的时候就已经确定 this 了
2. 箭头函数不能 作为构造函数使用
3. 箭头函数没有 arguments
4. 不能通过 call,apply,bind 改变 this 的指向
5. 箭头函数没有 prototype

# 状态码 常用

200 成功
301 永久重定向
302 临时重定向
304 命中协商缓存
400 客户端发送的报文中存在语法错误
401 没有权限
403 服务器禁止访问该资源
405 服务器禁止改请求方式访问
404 资源加载错误
401 没有权限
500 服务器内部错
502 网关或代理服务器出错
504 请求超时

# useMemo 和 useCallback 适用场景

useMemo 返回一个经过计算的值
不要滥用 useMemo：
在优化子组件渲染，或者当前组件依赖一个复杂计算的值的时候

useCallback 返回一个函数
不要滥用 useCallback：
用来优化子组件因函数不同造成重复渲染的问题
使用 useCallback 形成的闭包，将保持对回调函数和依赖项的引用

# 如何实现浅拷贝，和深拷贝

浅拷贝 object.assign()

深拷贝：
借用浅拷贝递归实现

```js
function deepClone(target, map = new WeakMap()) {
  if (typeof target === 'object') {
    let cloneTarget = Array.isArray(target) ? [] : {}
    // 循环引用
    if (map.get(target)) {
      return map.get(target)
    }

    map.set(target, cloneTarget)

    for (key in target) {
      cloneTarget[key] = deepClone(target[key], map)
    }
    return cloneTarget
  } else {
    return target
  }
}
```

# h5 的新特性

1. 语义化标签
2. audio ,video
3. 本地存储
4. websocket
5. history

# http 2 特点 和 cdn 有什么关系

1. 多路复用,单个了连接可以并行进行请求和响应，解决队头阻塞的问题
2. 二进制帧协议传送,正因为二进制流才可以多路复用，因为每个帧都有标识属于哪个流，多个帧组成一个流
3. 头部压缩，减少传输的体积
4. 服务端推送，服务器会向浏览器推送与这个请求相关的资源，服务器可以缓存资源

cdn 支持 http2,可以在很大程度上缓解传输压力
如果存在 cdn 缓存，当本地缓存过期之后，会先向最近的 cdn 缓存进行查找，如果 cdn 缓存也过期，就会像源站点发出请求返回新的资源。

# BFC 用途

块级格式化上下文，是一个独立的容器，用于决定块级盒子的布局及影响的范围，
相当于 css 的属性，触发了 bfc 条件会形成  一个具有 bfc 特点的独立容器

BFC 创建：

- 根元素
- 浮动元素 （float 不为 null）
- 绝对定位元素 ( position 为 absolute 或 fixed)
- 有 overflow 且不是 visible 的元素
- 内联元素，表格元素 display：inline-block display：table-cell display:table-captions

BFC 解决的问题：

- 父元素高度塌陷，在正常文档流中父元素如果没高度，需要子元素撑起来，如果子元素设置成了 BFC 就会脱离文档流，导致父元素塌陷
  解决办法

  1.  为父元素设置 overflow:hidden
  2.  利用清除浮动 在浮动元素下添加一个 div 用 clear:both 来清除浮动 或利用伪类来清除浮动

- margin 重叠 ,同属于一个 BFC 的相邻两个 box 会发生 margin 重叠
  解决办法给这个两个 box 外层的父元素设置 BFC
- 清除浮动
  给父元素也设置 BFC,例如给父级元素添加 overflow:hidden 属性
- 自适应两栏布局

# 实现水平垂直居中的方式

1.  绝对定位 + -margin 父元素设置 relative ，子元素设置 position: absolute; left: 50%; top: 50%; margin-left：-元素宽的一半，margin-top: - 元素高的一半

```css
.box {
  width: 200px;
  height: 200px;
  border: 1px solid red;
  position: relative;
}
.children-box {
  position: absolute;
  width: 100px;
  height: 100px;
  background: yellow;
  left: 50%;
  top: 50%;
  margin-left: -50px;
  margin-top: -50px;
}
```

2. 绝对定位 + transform(-50%,-50%)
   父元素设置 relative ，子元素设置 position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);

3. 绝对定位 + top,bottom,left,right = 0 + margin:auto
   父元素设置 relative ，子元素设置 position: absolute; left:0;right:0;top:0;bottom:0; margin:auto;

4. flex 布局
5. grid 布局，父元素设置 display:flex, 子元素设置 margin：auto
6. table-cell 父元素设置 display: table-cell; text-align: center; vertical-align: middle;

# css 重绘，重流

浏览器在渲染阶段会经历 dom 解析，cssOM 解析, 最后合并成 render Tree 就能获取元素在页面上的大小位置，最终绘制出来
什么是回流？
当 render tree 中的一部分元素因为大小，布局，隐藏等改变需要重新构建，称为回流。
什么是重绘？
当 render tree 的元素需要更新属性，这些属性只影响元素外观，风格，不影响布局的，则称为重绘。

重流一定重绘，重绘不一定重流

会导致重流的一些操作：

1. 页面首次渲染
2. 元素尺寸的改变，位置的改变，内容的改变
3. 窗口的改变
4. 字体大小的改变

会导致重绘的操作：

1. color ,background-color 的改变

避免回流和重绘？

1. 避免使用 table 布局
2. 将动画效果脱离文档流
3. 避免使用 calc
4. 尽可能在 dom 树末端改变 css
5. 避免重复操作样式，最好一次性重写 style
6. 必要时，可以为元素设置 display:none ...

# flex 中 1 代表什么

flex 是 flex-grow ,flex-shrink,flex-basis 的结合
flex-grow:项目的放大比例：默认为 0
flex-shrink:项目的缩小比例：默认为 1 ,若空间不足，则缩小比例
flex-basis:计算项目空间，默认为 auto,即项目本身大小

flex 1 === flex 1 1 0%

# css 实现一个三角形

- 利用 border 属性

```css
.triangle {
  height: 0;
  width: 0;
  border-color: red transparent transparent transparent;
  border-style: solid;
  border-width: 30px;
}
```

- 利用 clip-path

```css
.triangle {
  width: 30px;
  height: 30px;
  background: red;
  clip-path: polygon(
    0px 0px,
    0px 30px,
    30px 0px
  ); // 将坐标(0,0),(0,30),(30,0)连成一个三角形
  transform: rotate(225deg); // 旋转225，变成下三角
}
```

# 移动端 1px

在设备像素比大于 1 的情况下，有些设备会出现 1px 在一些屏幕上很粗的现象，如何解决？

1. 利用::after + transfrom 进行缩放

```css
.scale::after {
  display: block;
  content: '';
  border-bottom: 1px solid #000;
  transform: scaleY(0.5);
}
```

2. border-image
   根据媒体查询不同的像素比给定不同的 border-image
3. box-shadow

```css
div.shadow {
  box-shadow: 0 0.5px 0 0 #000;
}
```

# rem 原理

em 是以父元素的的 font-size 为单位的

rem 是一个相对单位，是相对于根元素的 font-size 值来设定的
假设 font-size 的值为 37.5px 则 1rem = 37.5 2rem = 75px

如何设定 font-size

1. 媒体查询, 设定每种屏幕对应的 font-size
2. js 设置 font-size 一般比较常用
   n 代表想要让字体大小成为屏幕的 n /1 公式是= 元素的宽度 /UI 图的宽度 \* 100

```js
function refreshRem() {
  var docEl = document.documentElement
  var width = docEl.getBoundingClientRect().width
  var rem = width / n
  document.documentElement.style.fontSize = rem + 'px'
  flexible.rem = win.rem = rem
}
win.addEventListener('resize', refreshRem)
```

3.  使用 vw 设置

```css
html {
  font-size: 10vw;
}
```

# 移动端做处理

1. 媒体查询
   需要定义不同尺寸下的样式，比较繁琐
2. %
   需要计算元素的%，% 的相对元素不同，width 和 height 相对于父元素的 width 和 height，而 margin、padding 相对于父元素的宽度
3. rem
   在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。
4. vw,vh

# flex 介绍，及参数 flex 1

flex 又称为弹性布局，使用 flex 布局的元素称为容器，容器里面的元素又称为项目

flex-direction,flex-warp,flex-flow,justify-content,align-items,align-content,align-self 等

# react 中父组件调子组件的方法

主要是需要拿到子组件的实例，在调用子组件的方法

1. 通过传递 this 实例的方法， 父组件定义实例的方法 onRef(ref){ this.child =ref}, 子组件调用该方法传入实例 this.props.onRef(this)
2. useRef
3. useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。

# new 的过程

1.  创建一个新对象
2.  取出第一个参数作为构造函数
3.  将对象的 _proto_ 指向构造函数的 prototype
4.  改变 this 指向，将构造函数的 this 指向 new 出来的对象
5.  返回该对象

```js
function ObjectFactory() {
  const obj = Object.create(null)
  Constructor = [].shift.call(argument)
  obj._proto_ = Constructor.prototype
  const result = Constructor.apply(obj, argument)

  return typeof result === 'object' ? result : obj
}
```

# promise 的 catch 和 try catch 有什么区别

try catch 只能捕获同步代码错误，无法捕获代异步错误。不能捕获 promise.reject()的错误
只能捕获到主线程执行到 try catch 中的错误， 比如一些语法错误，在检查的时候就报错了，不会走到 try catch 代码块

promise 对象错误具有冒泡性质，会一直向后传递直到捕获为止

# 虚拟 dom ,diff

时间复杂度 为 O(n)

1. 只比较同一层级，不跨级比较
2. tag 不相同，则直接删掉重建，不再深度比较
3. tag 和 key ，两者都相同，则认为是相同节点，不再深度比较

# webpack 的优化

1. exclude/include
2. cache-loader
3. happypack
4. noParse
5. IgnorePlugin

# webpack loader css 顺序

less-loader 加载.less 文件
css-loader 加载 .css 文件
styled-loader 将样式通过<style>标签插入到 header 中

执行顺序是 less-loader ---> css-loader --->styled-loader
webpack 加载是从右往左加载
use: [
'style-loader',
'css-loader',
'less-loader'
]

# loader plugin，常用

常用的 loader
image-loader,sass-loader,css-loader,style-loader,babel-loader...

常用的 plugin
html-webpack-plugin,ignore-plugin,mini-css-extract-plugin (分离样式文件)，happypack-plugin

# node 事件循环机制

    node 中也有宏任务和微任务
     宏任务： setTimeout,setInterval,setImmediate,I/O 操作等
     微任务： process.nextTick(), promise.then()等

node 中时间轮询执行的顺序：
输入数据-->轮询阶段--->check 阶段 --->close 阶段 ---> timer 阶段 ---> pending 阶段 ---> idle 空闲阶段 --->轮询阶段

1. timer: 定时器阶段，setTimeout,setInterval ,如果到达时间，执行回调
2. I/O callbacks： 上一轮循环中未执行的 I/O 回调
3. idle, prepare: 仅系统内部使用
4. poll
   到达这个阶段后：

   - 如果存在定时器，并且到达时间了，则回到 timer 阶段
   - 如果没有定时器，则执行 poll 队列中的事件
     （1）如果队列不为空，则依次执行，直到队列为空
     (2) 如果队列为空，检查是否有 setImmediate，有则进入 check 阶段， 没有则等待 callback 加入队列

5. check: 检查阶段 ,setImmediate 回调
6. close: 关闭阶段，一些关闭事件的回调，如 socket.on('close', ...)

process.nextTick 是一个独立于 eventLoop 的任务队列。 一般是在 poll 阶段执行，也有可能在 check 阶段执行，
在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

node 中宏任务和微任务的执行顺序：
v10 之前：

执行完阶段中的所有任务
执行 nextTick 队列中的任务
清空微任务队列中的任务
v10 之后与浏览器中的宏任务和微任务执行顺序一样，都是在执行完本次宏任务之后就立即执行微任务队列中的任务

node 和浏览器 事件轮询的区别：
在浏览器中微任务是在每个宏任务之后执行的，而 node 中的微任务是在每个阶段都会执行

# createRef 和 useRef 的区别

1. useRef 只能用在 function 组件
2. createRef 建议用在 class 组件，因为如果用在 function 组件，每次都会生成新的引用，新的 ref,每次都得初始化

# new Number("123") 和 Number("123") 区别

typeof new Number("123") 返回 object
typeof Number("123") 返回 number

new Number("123") = Number{123} 返回包装后的类型
Number("123") = 123

# for of for in

for in 一般用来遍历对象，可以遍历到原型链上的属性 （i {} in 对象，在对象里） ，如果用 for in 遍历数组只能打印出索引值，不推荐，不能用 break ,continue ,return 跳出函数体

for of 用来遍历实现了 Iterator 接口的， 如 数组，类数组，map,set,字符串等,遍历对象需要通过和 Object.keys(),可以使用 break ,continue ,return 跳出函数体

# 受控组件，非受控组件的区别

受控组件，非受控组件是 react 处理表单的入口

受控组件就是通过事件改变 value 的值
比如：<input/> <textarea> 默认是非受控组件，如果通过设置 value 和 onChange 进行了数据绑定，就转化成了受控组件

# 闭包 ， 闭包使用场景

闭包就是能够访问函数内部变量的函数，创建方法是在函数内部创建另一个函数

应用：

1. 定义模块，将模块内部的函数暴露给外部
2. 给对象设置私有属性
3. 立即执行函数

# react-router 实现，区别

react-router 分为 BrowserRouter， HashRouter

BrowserRouter 是通过 h5 的 API, history.pushState,replaceState 实现的
HashRouter 是通过 hashChange 来实现的

区别：

1. 表现形式不一样
2. 刷新后对路由 state 参数的影响
   BrowserRouter 没有任何影响，state 的值保存的 history 对象中
   HashRouter 刷新后会导致路由 state 参数的丢失

# 浮点数的处理

1. toFixed(2) 会对小数点后的位置做四舍五入
2. 使用第三方库 如 Math.js

# call ,apply,bind 的实现

1.  将函数设为对象的属性 context.fn = this
2.  执行该方法 context.fn(...arg)
3.  删除该属性 delete context.fn

```js
Function.prototype.myCall = function (context) {
  context = context || window
  context.fn = this
  const arg = [...arguments].slice(1)
  const result = context.fn(...arg)

  delete context.fn

  return result
}

// 同call 一样，只是参数不一样
Function.prototype.myApply = function (context) {
  context = context || window
  context.fn = this
  const arg = arguments[1]

  const result = context.fn(...arg)
  delete result
}
// bind 接收参数，返回参数

Function.prototype.myBind = function (context) {
  var self = this
  //获取myBind 参数从第二个到最后一个参数
  var args = Array.prototype.slice.call(arguments, 1)
  var fNOP = function () {}

  var fbound = function () {
    const bindArgs = Array.prototype.slice.call(arguments)
    self.apply(this instanceof self ? this : context, args.concat(bindArgs))
  }
  fNOP.prototype = this.prototype
  fbound.prototype = new fNOP()
  return fbound
}


```

# 同源站点间的通信

1. localStorage
2. BroadCast Channel 广播通信
   const bc = new BroadcastChannel('AlienZHOU');
   通过 bc.onmessage() 来监听，bc.postMessage() 发送数据

3. Service Worker 长期运行在后台的 worker
   监听消息 navigator.serviceWorker.addEventListener('message', function (e) {})
4. window.open
5. Websocket

# redux 过程

1. view 通过 store.getState() 获取 state 的值
2. 当需要更改数据时通过 view 页面发出 action
3. action 通过调用 store.dispatch()，把 action 和 state 传给 reducer
4. reducer 通过 actionType 返回对应的 state
5. state 一旦发生变化，就会调用监听函数 store.subscribe，来通知 view 页面数据发生了变化
6. state 改变就需要重新 render

# redux 中执行异步方法

通常会借助异步中间件来处理，比较流行的是 redux-chunk,redux-saga

redux-chunk
优点： 代码体积小，使用简单
缺点： 样板代码多
redux-chunk 使用

```js
import { createStore, applyMiddleware, compose } from 'redux'
import reducer from './reducer'
import thunk from 'redux-thunk'

// 设置中间件，可设置多个中间件
const enhancer = compose(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store
```

redux-saga:

缺点：代码体积大，语法比较复杂

# redux 中间件，洋葱模型

// next 就相当于 dispatch

```js
const reduxMiddleware = store => next => action => {
  // ...
  next(action)
  // ...
}
```

洋葱模型：洋葱模型中的每一层都是一个中间件，每次都会从最外层一层一层的经过中间件，等到了最里层的中间件后开始逐层的返回。所以在一次请求和响应的时机中都有两次时机来添加不同的处理逻辑

dispatch = compose(...chain)(store.dispatch)

dispatch 绑定了各个中间件的 next

好处？实现？koa-router

# router 跳转 state 中的值

1. 把数据存到 storage 中
2. 通过路由传参
3. 在同一个页面处理，跳转路由，返回不同的组件

# 排序，时间复杂度，空间复杂度

时间复杂度：衡量算法运行的时间

空间复杂度：是算法在运行过程中占用存储大小的量度

# css 隐藏元素，几种渲染有什么不同

1. opacity：0 ,位置还在,并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件
2. visibility：hidden 位置还在,但是不会触发绑定事件
3. display:none 位置不在，会导致浏览器重排和重绘
4. z-index： 设置层级较大
5. position 定位到屏幕外

# object 数组遍历

object 遍历:
Object.keys()
Object.values()
Object.entries()
for in

数组遍历：
for,for of ,forEach
map
filter
some 有一项为 true 则为 true
every 每一项为 true 则为 true
reduce
find
findIndex

# 节流，防抖，使用场景

```js
function debounce(fn, interval) {
  let timer = null

  return function () {
    let self = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }

    setTimeout(() => {
      fn.apply(self, args)
    }, interval)
  }
}

function throttle(fn, interval) {
  let last = null

  return function () {
    let now = Date.now()
    let self = this
    let args = arguments

    if (last - now > interval) {
      clearTimeout(timer)
    }
    last = now

    setTimeout(() => {
      fn.apply(self, args)
    }, interval)
  }
}

function throttle(fn, interval) {
  let timer = null

  return function () {
    let self = this
    let args = arguments
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(self, args)

        timer = null
      }, interval)
    }
  }
}

function throttle(fn, interval) {
  let timer = null
  let startTime = 0

  return function () {
    let self = this
    let args = arguments
    let currentTime = Date.now()
    let running = interval - (currentTime - startTime)

    clearTimeout(timer)

    if (running <= 0) {
      fn.apply(this, args)
      startTime = Date.now()
    } else {
      timer = setTimeout(() => {
        fn.apply(this, args)
        startTime = Date.now()
      }, running)
    }
  }
}
```

防抖： input 联想 ,窗口大小改变
节流： 滚动事件，鼠标不断点击

# 输入 url 到页面渲染

1. 浏览器缓存

## 缓存

缓存分为强制缓存和协商缓存

强制缓存：不需要向服务端发送请求，直接是读取本地存储，也不需要域名解析和 tcp 链接，强制缓存在 http 中的状态码是 200
主要通过 Expires,Catch-Control,Pragma 几个属性来控制
Expires :过期时间，会根据系统时间和 Expires 来判断是否过期，但是系统时间有可能不准确（本地时间）
Catch-Control :

- max-age:单位是秒，是指从请求发起到缓存失效的时间，指强缓存失效的时间
- no-catch:使用协商缓存，需要询问服务端缓存是否有效，有效返回 304，无效返回新的资源
- no-store: 不使用缓存
- public: 响应可以被中间代理，cdn 等去缓存
- private: 个人缓存，中间代理，cdn 不允许缓存

Pragma:no-catch 同 catch-control 的 no-catch 一样，不使用强制缓存

协商缓存：在没有命中强制缓存的情况下会走协商缓存
在请求头设置了 if-Modified-Since 或 if-None-Match 时，服务端会查看是否命中缓存，命中会返回 304，并在响应头设置 Last-Modified 和 ETag 属性

Last-Modified/if-Modified-Since:代表文件的过期时间，在第一次请求时，服务端会在响应头中设置 Last-Modified。在第二次请求时浏览器会携带 if-Modified-Since 为上次服务端返回的响应值。服务端会根据最后修改时间 If-Modified-Since 做对比，如果相同就返回 304，不同则返回新资源
ETag/if-None-Match : 代表文件的唯一 hash 值，只有文件发生改变的时 hash 值才会改变

2. 域名解析
   查看是否有缓存，如果有缓存直接使用缓存中的 ip 地址
   由于数据包是通过 ip 地址传给对方的，所以需要域名解析。域名解析就是把域名解析成 IP 地址的过程
   浏览器提供了 DNS 数据缓存功能，如果域名已经被解析过，就不用再进行域名解析，会直接使用缓存里的
3. 建立 tcp 连接

- 三次握手： 确认客户端和服务端的接收和发送能力都正常
- 发送数据：接收端在接收到数据之后必须向发送端发送确认信号来保证数据没有丢包
- 四次挥手： 通过四次挥手来断开连接

4. 发送 http 请求
   请求包括：请求行，请求头，空行，请求体
   常见的请求头包括：
   Cache-Control, Expires,if-Modified-Since,Accept,Accept-Encoding,Accept-Language,Connection,Cookie,Host

   发送请求到服务端之后，服务端会给予响应，响应包括：响应行，响应头，响应体

   http1.0
   短连接
   http1.1

   - 长连接
   - 缓存的头部字段
   - 宽带优化及网络连接的处理
   - 错误通知管理，新增了错误状态码
   - host 头处理

   http2.0

   - 支持二进制传送
   - 多路复用
   - 支持服务端推送
   - 头部压缩

5. 渲染页面
   - 构建 dom 树
     利用 token 解析成 dom 树 挂载到 document 上
   - 构建 CSSOM 树
     收集 css 规则 style 标签中的样式，内敛样式，外部引用的样式，给 dom 节点添加样式信息
   - 生成渲染树
     给 dom 树添加位置信息
   - 建立图层
     每层中样式的绘制不会影响到其他层
   - 分块 生成绘制列表
     生成图块
   - 栅格化
     把图块转成位图的过程
   - 展示
6. 断开连接

# setState

setState 是同步的还是异步的

1. setState 是在合成事件(react 封装的自己的一套事件机制如 onClick、onChange 这些都是合成事件)和生命周期钩子函数里，是异步的。在原生事件和 setTimeout 中是同步的
2. setState 本身的过程和代码都是同步的，所谓“异步”是因为合成事件和钩子函数处在 react 的更新机制中，isBatchingUpdates 为 true,只会加入待更新的队列中，
   然后在之后才会更新，所以在此时无法拿到更新后的值就造成了异步的假象
   在 setTimeout 中，这时上一轮的更新过程已经执行完毕，isBatchingUpdates 为 false,所以此时能拿到 setState 的值
3. 如果 setState 传入的是对象的话，会合并成一次执行，如果是函数的话，不会被合并，都会执行

setState 实现过程

1. 将 setState 传入的参数存到 \_pendingStateQueue 队列中
2. 判断当前组件是否处于批量更新阶段 isBatchingUpdates，如果是则加入待更新的队列 dirtyComponent 中，否则则执行更新事务(transcation)
3. 遍历 dirtyComponent 队列依次更新，调用 wrapper 的 initialize 方法，更新 isBatchingUpdates，state,props
4. 执行生命周期 componentWillReceiveProps。
5. 将组件的 state 暂存队列中的 state 进行合并，获得最终要更新的 state 对象，并将队列置为空。
6. 执行生命周期 componentShouldUpdate，根据返回值判断是否要继续更新。
7. 执行生命周期 componentWillUpdate。
8. 执行 render。
9. 执行生命周期 componentDidUpdate。

# fiber

在引入 fiber 架构之前，是采用对比新旧 dom 树来对比不同，再去重新渲染，但是在此过程中会占用浏览器资源，如果有更高优先级的任务就会出现卡死的现象。为了解决这些问题，引入了 fiber 架构
fiber 把任务拆分成多个小的任务，这些任务是随时可以被中断的和恢复的，从而执行更高优先级的任务

requestIdleCallback 是在浏览器空闲的时候执行的回调函数

fiber 树

根据 dom 树生成 fiber 树，fiber 树包含 child（此节点的第一个子节点）,sibling（此节点的兄弟节点）,return（指向父节点） 等属性

采用后序遍历 从顶点开始遍历，先子节点，再兄弟节点，完成所有子节点后自己才完成

fiber 的更新过程分为两个阶段：
render 阶段：任务可被中断，找出所有节点的变更
commit 阶段：任务不能中断，执行所有的变更

# immer 原理

react 中数据是不可变的，如果是通过 redux 来修改 state 值时需要返回一个新的值，假如是修改一个对象，就需要对它做层层解构或者深拷贝,来生成一个新的对象来返回，这样书写上会麻烦，并且会新拷贝一个无用的新对象

immer 主要是为了解决复杂对象修改麻烦的问题。是利用 ES6 的 proxy 对象，当修改某个值时会生成 state 的草案，通过 set,get 方法修改某个属性对应的值，其他没有修改的不做修改，性能得到很大的提升

# Type interface 什么时候用

- 如是在定义一些库的话可以使用 interface ,方便使用者去扩展
- 如果是定义一些属性的话可以使用 type
- type 和 interface 能达到一样的效果，但 interface 可以做合并，可以做添加，type 不能做二次修改,type 可以定义一些基本类型的变量，interface 不可以
- type 可以动态计算属性,interface 不可以

```js
type Keys = "小王" | "小文"
type X = {
  [k in keys]:string
}
```

# 以下代码输出

```js
setTimeout(_ => {
  Promise.resolve('h').then(r => {
    console.log(r) // h
  })
  console.log('g')
})
setTimeout(_ => {
  console.log('t')
})
async function pFn() {
  return new Promise(resolve => {
    resolve('r')
    console.log('o')
  })
}
async function entry() {
  console.log('y')
  const p = await pFn()
  Promise.resolve('i').then(r => console.log(r))
  console.log(p) // r
}
entry()
console.log('u')
// y o u r i g h t
```

# 页面上有一个 Input 输入框，假设 id 为 "example" JS 中有一个对象 test，要求 test.value 和输入框的值实现双向数据绑定 当在输入框中输入任意内容时，test.value 则变成相应值，并在控制台输入该值 当在 JS 中将 test.value 赋值为任意内容时，输入框内容显示相应内容

```html
<input id="example" /> <button onclick="handleClick()">改变test</button>
```

```js
const test = { value: '' }
const inputTarget = document.getElementById('example')

function changeValue(v) {
  test.value = v
  inputTarget.value = test.value
}

function handleOnchange() {
  changeValue(inputTarget.value)
  console.log('value', inputTarget.value, 'test', test)
}

function handleClick() {
  changeValue(1234)
}
```

# 前端代码中， require 机制可能存在循环依赖的问题。比如实际代码依赖链路可能存在这种情况： a.js -> b.js -> c.js -> d.js -> b.js ，出现了循环依赖。 如下给出了某个项目 A 的模块依赖关系样例数据：deps, 请实现一个方法，检测其中是否存在的循环引用，并打印出现循环依赖的引用链条。

```js
const deps = {
  'a.js': { deps: ['b.js', 'e.js'] },
  'b.js': { deps: ['c.js'] },
  'c.js': { deps: ['d.js'] },
  'd.js': { deps: ['a.js'] },
}

function checkCircularReference(obj) {
  let result = []
  let flag = false
  for (let key of Object.keys(obj)) {
    if (flag) {
      break
    }

    const checkItem = (dep, depsMemo, chain) => {
      if (depsMemo[dep]) {
        flag = true
        result = [...chain, dep]
        return
      }
      depsMemo[dep] = true
      chain.push(dep)

      obj[dep]?.deps.forEach(item => {
        checkItem(item, depsMemo, [...chain])
      })
    }
    checkItem(key, {}, [])
  }
  return result
}
console.log(checkCircularReference(deps))
```

# Node 多个大文件处理 一个目录下有较多内容较大的文本文件，假设该目录为 /tmp/source 需要在每个文件最后一行加上 Hello, Lazada~ 的文本，并将所有文件移到另一个目录，目录路径假设为 /tmp/dest 用 Node 实现，尽量考虑机器性能

```js
const fs = require('fs')
const path = require('path')
function copyFile(src, dist) {
  fs.createReadStream(src).pipe(fs.createWriteStream(dist))
}

function dealFile(originPath, targetPath) {
  fs.readdir(originPath, (_, file) => {
    file.forEach(item => {
      const filePath = path.join(originPath, item)
      fs.writeFileSync(filePath, 'hello', () => {
        console.log('写入成功')
      })

      copyFile(filePath, path.join(targetPath, item))
    })
  })
}
dealFile(__dirname + '/source', __dirname + '/dest')
```

# 实现一个方法，若干的请求，有任意两个失败，也返回失败，全部成功在返回成功

```js
function createNewRequest(rejectCount, promiseArr) {
  const result = []
  let rejectCnt = 0
  let resolveCnt = 0

  return new Promise((resolve, reject) => {
    promiseArr.forEach((promise, index) => {
      promise
        .then(data => {
          resolveCnt++
          result[index] = data

          if (resolveCnt === promiseArr.length) {
            resolve(result)
          }
          console.log(data)
        })
        .catch(err => {
          rejectCnt++
          if (rejectCnt === rejectCount) {
            reject(err)
            new Function()
          }
        })
    })
  })
}

let p1 = Promise.resolve(1)
let p2 = Promise.resolve(2)
let p3 = Promise.reject(3)
let p4 = Promise.resolve(4)

createNewRequest(1, [p1, p2, p3, p4]).then(res => {
  console.log(999999999, res)
})
```

# 缓存的图片路径不变，图片发生了改变，如何获取最新的图片

1. 给图片地址后面拼接一个 hash 值如 Math.random()
2. 修改 html

   <meta http-equiv="Pragma" content="no-cache">
   <meta http-equiv="Cache-Control" content="no-cache">
   <meta http-equiv="Expires" content="0">

3. js 更新缓存
   window.applicationCache.update();

# 同名文件更新，存在 CDN 缓存的问题

# 七牛云和阿里云的差别

# 阿里云公读公写还是公读私写

# 文件的压缩处理

# 小程序和 h5 的区别,flutter

# 小程序和移动端是如何调起对方的事件的

# generator 实现

# promise 规范

# 观察者设计者模式

# 如何终止异步方法

# websocket

# 你看过 react 源码不

# 怎么接收后端传进来的 long 型的数据

# antd 3 和 antd 4 的区别

# node 原生的 API 有哪些，node sync 和普通的有什么区别

# setState 输出

# React 合成事件，为什么要有合成事件

# React.lazy 的实现

# webpack 如何动态加载的

# Async 的并发实现:同时处理一组请求，返回一组处理完的结果，错误也返回

# Webpack 的优化，大小速度，tree-shaking

# 热更新原理 是 id 还是内容

# Promise 的合成事件是同步的还是异步的，哪个方法返回一个新的 promise，缺点
